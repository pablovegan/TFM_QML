{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"QubitApproximant","text":"<p>A <code>python</code> package for approximating quantum circuits with a single qubit.</p> <p></p>"},{"location":"#documentation-and-examples","title":"Documentation and examples","text":"<p>Documentation created with <code>mkdocs</code> can be found in https://pablovegan.github.io/QubitApproximant/.</p>"},{"location":"#installation","title":"Installation","text":"<p>With <code>pip</code>: <pre><code>pip install qubit-approximant\n</code></pre></p>"},{"location":"#quick-usage","title":"Quick usage","text":""},{"location":"#importing-a-function","title":"Importing a function","text":"<p>In the submodule benchmarking.functions there are multiple test functions to choose from</p> <pre><code>import numpy as np\nfrom qubit_approximant.benchmarking.functions import gaussian\n\nx = np.linspace(-2.5, 2.5, 1000)\nfn_kwargs = {'mean': 0.0, 'std': 0.5, 'coef': 1}\nfn = gaussian(x, **fn_kwargs)\n</code></pre>"},{"location":"#creating-a-circuit","title":"Creating a circuit","text":"<p>To create a circuit just choose the ansaz (<code>CircuitRxRyRz</code>, <code>CircuitRxRy</code> or <code>CircuitRy</code>) and the encoding (<code>'prob'</code> or <code>'amp'</code>).</p> <pre><code>from qubit_approximant.core import CircuitRxRyRz\n\ncircuit = CircuitRxRyRz(x, encoding='prob')\n</code></pre>"},{"location":"#cost-function","title":"Cost function","text":"<p>To find the optimum parameters of the circuit, we need to choose a cost function. This can be done with the <code>Cost</code> class, where we input the function to approximate, the circuit ansatz and a metric to quantify the error in the approximation (options are <code>'mse'</code>, <code>'rmse'</code>, <code>'mse_weighted'</code>, <code>'kl_divergence'</code> or <code>'log_cosh'</code>)</p> <pre><code>from qubit_approximant.core import Cost\n\ncost = Cost(fn, circuit, metric='mse')\n</code></pre>"},{"location":"#optimizer","title":"Optimizer","text":"<p>Choose an optimizer (<code>BlackBoxOptimizer</code>, <code>GDOptimizer</code> or <code>AdamOptimizer</code>)</p> <p><pre><code>from qubit_approximant.core import BlackBoxOptimizer\n\noptimizer = BlackBoxOptimizer(method=\"L-BFGS-B\")\n</code></pre> and find the optimum parameters for the chosen circuit</p> <pre><code>layers = 6\ninit_params = np.random.default_rng().standard_normal(4 * layers)\nopt_params = optimizer(cost, cost.grad, init_params)\n</code></pre>"},{"location":"#multilayer-optimizer","title":"Multilayer optimizer","text":"<p>We may also optimize an ansatz for multiple layers using the <code>LayerwiseOptimizer</code>, which uses the optimum parameters for a circuit with $L$ layers as initial parameters for the optimization of a circuit with $L+1$ layers. A list with the optimum parameters for each layer is returned.</p> <pre><code>from qubit_approximant.core import LayerwiseOptimizer\n\nlayerwise_opt = LayerwiseOptimizer(\n    optimizer,\n    min_layer=3,\n    max_layer=7, \n    new_layer_coef=0.3,\n    new_layer_position='random'\n    )\nparams_list = layerwise_opt(cost, cost.grad, init_params)\n</code></pre> <p>Note: a <code>MultilayerOptimizer</code> which doesn't reuse the optimized parameters from previous layers is also available.</p>"},{"location":"#error-metrics","title":"Error metrics","text":"<p>To benchmark the optimization we can use some common metrics, like the $L^1$ norm, $L^2$ norm, $L^\\infty$ norm or infidelity $1-F$, to compare the function encoded in the circuit with the desired function. Following our example, <code>fn</code> is a <code>gaussian</code>:</p> <pre><code>l1_list, l2_list, inf_list, infidelity_list = metric_results(\n    params_list,\n    circuit,\n    fn = gaussian,\n    fn_kwargs = {'mean': 0.0, 'std': 0.5, 'coef': 1}\n    )\n</code></pre>"},{"location":"#wrapping-up","title":"Wrapping up","text":"<p>Test the library yourself!</p> <pre><code>import numpy as np\n\nfrom qubit_approximant.benchmarking.functions import gaussian\nfrom qubit_approximant.core import CircuitRxRyRz, Cost, BlackBoxOptimizer, LayerwiseOptimizer\nfrom qubit_approximant.benchmarking import metric_results\n\nx = np.linspace(-2.5, 2.5, 1000)\nfn_kwargs = {'mean': 0.0, 'std': 0.5, 'coef': 1}\nfn = gaussian(x, **fn_kwargs)\n\ncircuit = CircuitRxRyRz(x, encoding='prob')\ncost = Cost(fn, circuit, metric='mse')\noptimizer = BlackBoxOptimizer(method=\"L-BFGS-B\")\n\nmin_layer = 3\ninit_params = np.random.default_rng().standard_normal(4 * min_layer)\nlayerwise_opt = LayerwiseOptimizer(\n    optimizer,\n    min_layer=min_layer,\n    max_layer=7,\n    new_layer_coef=0.3,\n    new_layer_position='random'\n    )\nparams_list = layerwise_opt(cost, cost.grad, init_params)\n\nl1_list, l2_list, inf_list, infidelity_list = metric_results(\n    fn=gaussian,\n    fn_kwargs={'mean': 0.0, 'std': 0.5, 'coef': 1},\n    circuit=circuit,\n    params_list=params_list\n    )\n</code></pre>"},{"location":"#bonus-benchmarking-multiple-initial-parameters","title":"Bonus: benchmarking multiple initial parameters","text":"<p>The initial paramenters for the optimizer are generated at random with a <code>seed</code> of our choice. We can benchmark the optimizer against multiple seeds (since it is a time consuming task it is parallelized using <code>mpi</code>).</p> <pre><code>benchmark_seeds(\n    num_seeds = 4,\n    fn = gaussian,\n    fn_kwargs = fn_kwargs,\n    circuit = circuit,\n    cost = cost,\n    optimizer = multilayer_opt,\n    filename = \"results\",\n)\n</code></pre>"},{"location":"#references","title":"References","text":"<p>This library is based on Adrian P\u00e9rez Salinas article Data re-uploading for a universal quantum classifier.</p>"},{"location":"#contributing","title":"Contributing","text":"<p>Pull requests are welcome. For major changes, please open an issue first to discuss what you would like to change.</p> <p>Please make sure to update tests as appropriate.</p>"},{"location":"#license","title":"License","text":"<p>This software is under the GNU General Public License v3.0.</p>"},{"location":"reference/","title":"qubit_approximant","text":""},{"location":"reference/#qubit_approximant","title":"<code>qubit_approximant</code>","text":""},{"location":"reference/_version/","title":"_version","text":""},{"location":"reference/_version/#qubit_approximant._version","title":"<code>qubit_approximant._version</code>","text":""},{"location":"reference/benchmarking/","title":"benchmarking","text":""},{"location":"reference/benchmarking/#qubit_approximant.benchmarking","title":"<code>qubit_approximant.benchmarking</code>","text":""},{"location":"reference/benchmarking/functions/","title":"functions","text":""},{"location":"reference/benchmarking/functions/#qubit_approximant.benchmarking.functions","title":"<code>qubit_approximant.benchmarking.functions</code>","text":""},{"location":"reference/benchmarking/functions/functions/","title":"functions","text":""},{"location":"reference/benchmarking/functions/functions/#qubit_approximant.benchmarking.functions.functions","title":"<code>qubit_approximant.benchmarking.functions.functions</code>","text":"<p>Functions to test our quantum approximator.</p>"},{"location":"reference/benchmarking/functions/functions/#qubit_approximant.benchmarking.functions.functions.gaussian","title":"<code>gaussian(x, mean=0.0, std=1, coef=None)</code>","text":"<p>Return a gaussian function.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>NDArray</code> <p>Grid in which to approximate the function.</p> required <code>mean</code> <code>float</code> <p>Mean of the gaussian, by default 0.0</p> <code>0.0</code> <code>std</code> <code>float</code> <p>Standard deviation, by default 1</p> <code>1</code> <code>coef</code> <code>float</code> <p>Factor that multiplies the gaussian., by default None</p> <code>None</code> <p>Returns:</p> Type Description <code>NDArray</code> <p>Values of the gaussian at each point.</p> Source code in <code>qubit_approximant/benchmarking/functions/functions.py</code> <pre><code>def gaussian(\n    x: NDArray, mean: float = 0.0, std: float = 1, coef: Optional[float] = None\n) -&gt; NDArray:\n\"\"\"Return a gaussian function.\n\n    Parameters\n    ----------\n    x : NDArray\n        Grid in which to approximate the function.\n    mean : float, optional\n        Mean of the gaussian, by default 0.0\n    std : float, optional\n        Standard deviation, by default 1\n    coef : float, optional\n        Factor that multiplies the gaussian., by default None\n\n    Returns\n    -------\n    NDArray\n        Values of the gaussian at each point.\n    \"\"\"\n    if coef is None:\n        coef = 1 / (std * np.sqrt(2 * np.pi))\n    return coef * np.exp(-((x - mean) ** 2) / (2 * std**2))\n</code></pre>"},{"location":"reference/benchmarking/functions/functions/#qubit_approximant.benchmarking.functions.functions.lorentzian","title":"<code>lorentzian(x, x0=0.0, gamma=1.0)</code>","text":"<p>Return a lorentzian function.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>NDArray</code> <p>Grid in which to approximate the function.</p> required <code>x0</code> <code>float</code> <p>Shift x by this value, by default 0.0</p> <code>0.0</code> <code>gamma</code> <code>float</code> <p>Parameter of the lorenztian, by default 1.0</p> <code>1.0</code> <p>Returns:</p> Type Description <code>NDArray</code> <p>Values of the lorentzian at each point.</p> Source code in <code>qubit_approximant/benchmarking/functions/functions.py</code> <pre><code>def lorentzian(x: NDArray, x0: float = 0.0, gamma: float = 1.0) -&gt; NDArray:\n\"\"\"Return a lorentzian function.\n\n    Parameters\n    ----------\n    x : NDArray\n        Grid in which to approximate the function.\n    x0 : float, optional\n        Shift x by this value, by default 0.0\n    gamma : float, optional\n        Parameter of the lorenztian, by default 1.0\n\n    Returns\n    -------\n    NDArray\n        Values of the lorentzian at each point.\n    \"\"\"\n    return 1 / np.pi * gamma / ((x - x0) ** 2 + gamma**2)\n</code></pre>"},{"location":"reference/benchmarking/functions/functions/#qubit_approximant.benchmarking.functions.functions.poly","title":"<code>poly(x)</code>","text":"<p>Return 4th order a polynomial</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>NDArray</code> <p>Grid in which to approximate the function.</p> required <p>Returns:</p> Type Description <code>NDArray</code> <p>Values of the relu function at each point.</p> Source code in <code>qubit_approximant/benchmarking/functions/functions.py</code> <pre><code>def poly(x: NDArray) -&gt; NDArray:\n\"\"\"Return 4th order a polynomial\n\n    Parameters\n    ----------\n    x : NDArray\n        Grid in which to approximate the function.\n\n    Returns\n    -------\n    NDArray\n        Values of the relu function at each point.\n    \"\"\"\n    return np.abs((1 - x**4) * 3 * x**3)\n</code></pre>"},{"location":"reference/benchmarking/functions/functions/#qubit_approximant.benchmarking.functions.functions.relu","title":"<code>relu(x, a=1.0)</code>","text":"<p>Return a relu function      </p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>NDArray</code> <p>Grid in which to approximate the function.</p> required <code>a</code> <code>float</code> <p>Weight of x, by default 1.0</p> <code>1.0</code> <p>Returns:</p> Type Description <code>NDArray</code> <p>Values of the relu function at each point.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>\"a must be a positive constant\"</p> Source code in <code>qubit_approximant/benchmarking/functions/functions.py</code> <pre><code>def relu(x: NDArray, a: float = 1.0) -&gt; NDArray:\nr\"\"\"Return a relu function\n        $$f(x) = \\max(0, a \\cdot x)$$\n\n    Parameters\n    ----------\n    x : NDArray\n        Grid in which to approximate the function.\n    a : float, optional\n        Weight of x, by default 1.0\n\n    Returns\n    -------\n    NDArray\n        Values of the relu function at each point.\n\n    Raises\n    ------\n    ValueError\n        \"a must be a positive constant\"\n    \"\"\"\n    if a &lt;= 0:\n        raise ValueError(\"a must be a positive constant\")\n    return np.maximum(0, a * x)\n</code></pre>"},{"location":"reference/benchmarking/functions/functions/#qubit_approximant.benchmarking.functions.functions.sine","title":"<code>sine(x, a=1.0, b=0.0)</code>","text":"<p>Return a sine function.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>NDArray</code> <p>Grid in which to approximate the function.</p> required <code>a</code> <code>float</code> <p>Weight of x in the sine, by default 1.0</p> <code>1.0</code> <code>b</code> <code>float</code> <p>Shift of x in the sine, by default 0.0</p> <code>0.0</code> <p>Returns:</p> Type Description <code>NDArray</code> <p>Values of the sine at each point.</p> Source code in <code>qubit_approximant/benchmarking/functions/functions.py</code> <pre><code>def sine(x: NDArray, a: float = 1.0, b: float = 0.0) -&gt; NDArray:\n\"\"\"Return a sine function.\n\n    Parameters\n    ----------\n    x : NDArray\n        Grid in which to approximate the function.\n    a : float, optional\n        Weight of x in the sine, by default 1.0\n    b : float, optional\n        Shift of x in the sine, by default 0.0\n\n    Returns\n    -------\n    NDArray\n        Values of the sine at each point.\n    \"\"\"\n    return np.sin(a * x + b)\n</code></pre>"},{"location":"reference/benchmarking/functions/functions/#qubit_approximant.benchmarking.functions.functions.step","title":"<code>step(x, b=0.0, coef=1.0)</code>","text":"<p>Return a step function.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>NDArray</code> <p>Grid in which to approximate the function.</p> required <code>b</code> <code>float</code> <p>Shift of x, by default 0.0</p> <code>0.0</code> <code>coef</code> <code>float</code> <p>Size of the step, by default 1.0</p> <code>1.0</code> <p>Returns:</p> Type Description <code>NDArray</code> <p>Values of the step function at each point.</p> Source code in <code>qubit_approximant/benchmarking/functions/functions.py</code> <pre><code>def step(x: NDArray, b: float = 0.0, coef: float = 1.0) -&gt; NDArray:\n\"\"\"Return a step function.\n\n    Parameters\n    ----------\n    x : NDArray\n        Grid in which to approximate the function.\n    b : float, optional\n        Shift of x, by default 0.0\n    coef : float, optional\n        Size of the step, by default 1.0\n\n    Returns\n    -------\n    NDArray\n        Values of the step function at each point.\n    \"\"\"\n    return coef * np.heaviside(x, b)\n</code></pre>"},{"location":"reference/benchmarking/functions/functions/#qubit_approximant.benchmarking.functions.functions.tanh","title":"<code>tanh(x, a=5.0, coef=1.0)</code>","text":"<p>Return a hyperbolic tangent</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>NDArray</code> <p>Grid in which to approximate the function.</p> required <code>a</code> <code>float</code> <p>Weight of x, by default 5.0</p> <code>5.0</code> <code>coef</code> <code>float</code> <p>Coefficient of the hyperbolic tangent, by default 1.0</p> <code>1.0</code> <p>Returns:</p> Type Description <code>NDArray</code> <p>Values of the relu function at each point.</p> Source code in <code>qubit_approximant/benchmarking/functions/functions.py</code> <pre><code>def tanh(x: NDArray, a: float = 5.0, coef=1.0) -&gt; NDArray:\n\"\"\"Return a hyperbolic tangent\n\n    Parameters\n    ----------\n    x : NDArray\n        Grid in which to approximate the function.\n    a : float, optional\n        Weight of x, by default 5.0\n    coef : float, optional\n        Coefficient of the hyperbolic tangent, by default 1.0\n\n    Returns\n    -------\n    NDArray\n        Values of the relu function at each point.\n    \"\"\"\n    return coef * np.tanh(a * x)\n</code></pre>"},{"location":"reference/benchmarking/metrics/","title":"metrics","text":""},{"location":"reference/benchmarking/metrics/#qubit_approximant.benchmarking.metrics","title":"<code>qubit_approximant.benchmarking.metrics</code>","text":""},{"location":"reference/benchmarking/metrics/metric_results/","title":"metric_results","text":""},{"location":"reference/benchmarking/metrics/metric_results/#qubit_approximant.benchmarking.metrics.metric_results","title":"<code>qubit_approximant.benchmarking.metrics.metric_results</code>","text":""},{"location":"reference/benchmarking/metrics/metric_results/#qubit_approximant.benchmarking.metrics.metric_results.metric_results","title":"<code>metric_results(fn, fn_kwargs, circuit, params_list)</code>","text":"<p>Returns 4 lists of error metrics, one for each layer. The metrics are:     - L1 norm     - L2 norm     - Infinity norm     - Infidelity</p> <p>Parameters:</p> Name Type Description Default <code>fn</code> <code>Callable</code> <p>Function we want to approximate.</p> required <code>fn_kwargs</code> <code>dict</code> <p>Keyword arguments for 'fn'.</p> required <code>circuit</code> <code>Circuit</code> <p>Circuit used to model 'fn'.</p> required <code>params_list</code> <code>list[NDArray]</code> <p>List of parameters for the circuit with different number of layers.</p> required <p>Returns:</p> Type Description <code>Tuple[list[float], ...]</code> <p>Returns lists of L1 norms, L2 norms, infinity norms and infidelities for every number of layers.</p> Source code in <code>qubit_approximant/benchmarking/metrics/metric_results.py</code> <pre><code>def metric_results(\n    fn: Callable, fn_kwargs: dict, circuit: Circuit, params_list: list[NDArray]\n) -&gt; Tuple[list[float], ...]:\n\"\"\"Returns 4 lists of error metrics, one for each layer. The metrics are:\n        - L1 norm\n        - L2 norm\n        - Infinity norm\n        - Infidelity\n\n    Parameters\n    ----------\n    fn : Callable\n        Function we want to approximate.\n    fn_kwargs : dict\n        Keyword arguments for 'fn'.\n    circuit : Circuit\n        Circuit used to model 'fn'.\n    params_list : list[NDArray]\n        List of parameters for the circuit with different number of layers.\n\n    Returns\n    -------\n    Tuple[list[float], ...]\n        Returns lists of L1 norms, L2 norms, infinity norms and infidelities\n        for every number of layers.\n    \"\"\"\n    l1_list = []\n    l2_list = []\n    inf_list = []\n    infidelity_list = []\n\n    save_model_x = circuit.x.copy()  # copy just in case, although not necessary\n    x_limits = (circuit.x[0], circuit.x[-1])\n\n    def fn_eval(x):\n        return fn(x, **fn_kwargs)\n\n    for params in params_list:\n\n        def fn_approx_eval(x):\n            circuit.x = np.array([x])\n            return circuit.encoding(params)[0]  # one element array  # noqa: B023\n\n        l1_list.append(l1_norm(fn_eval, fn_approx_eval, x_limits))\n        l2_list.append(l2_norm(fn_eval, fn_approx_eval, x_limits))\n        infidelity_list.append(infidelity(fn_eval, fn_approx_eval, x_limits))\n\n        def fn_approx_inf_eval(x):\n            circuit.x = np.array(x)\n            return circuit.encoding(params)  # one element array  # noqa: B023\n\n        inf_list.append(inf_norm(fn_eval, fn_approx_inf_eval, x_limits))\n\n    circuit.x = save_model_x\n\n    return l1_list, l2_list, inf_list, infidelity_list\n</code></pre>"},{"location":"reference/benchmarking/metrics/metrics/","title":"metrics","text":""},{"location":"reference/benchmarking/metrics/metrics/#qubit_approximant.benchmarking.metrics.metrics","title":"<code>qubit_approximant.benchmarking.metrics.metrics</code>","text":""},{"location":"reference/benchmarking/metrics/metrics/#qubit_approximant.benchmarking.metrics.metrics.l1_norm","title":"<code>l1_norm(fn, fn_approx, x_limits)</code>","text":"<p>L1 norm of the difference of the given functions 'fn' and 'fn_approx'  in the interval given by (x_limits[0], x_limits[1]).</p> <p>Parameters:</p> Name Type Description Default <code>fn</code> <code>Callable</code> <p>Function we want to approximate.</p> required <code>fn_approx</code> <code>Callable</code> <p>Approximation to the function.</p> required <code>x_limits</code> <code>tuple[float, float]</code> <p>Limits of the integration interval to estimate the L1 norm of the difference between the function and the approximation.</p> required <p>Returns:</p> Type Description <code>float</code> <p>Value of the L1 norm (it is an integral).</p> Source code in <code>qubit_approximant/benchmarking/metrics/metrics.py</code> <pre><code>def l1_norm(fn: Callable, fn_approx: Callable, x_limits: tuple[float, float]) -&gt; float:\n\"\"\"L1 norm of the difference of the given functions 'fn' and 'fn_approx'\n     in the interval given by (x_limits[0], x_limits[1]).\n\n    Parameters\n    ----------\n    fn : Callable\n        Function we want to approximate.\n    fn_approx : Callable\n        Approximation to the function.\n    x_limits : tuple[float, float]\n        Limits of the integration interval to estimate the L1 norm of the difference\n        between the function and the approximation.\n\n    Returns\n    -------\n    float\n        Value of the L1 norm (it is an integral).\n    \"\"\"\n    diff_l1 = lambda x: np.abs(fn(x) - fn_approx(x))  # noqa\n    return integrate.quad(diff_l1, x_limits[0], x_limits[1], limit=300)[0]\n</code></pre>"},{"location":"reference/benchmarking/plot/","title":"plot","text":""},{"location":"reference/benchmarking/plot/#qubit_approximant.benchmarking.plot","title":"<code>qubit_approximant.benchmarking.plot</code>","text":""},{"location":"reference/benchmarking/plot/plot/","title":"plot","text":""},{"location":"reference/benchmarking/plot/plot/#qubit_approximant.benchmarking.plot.plot","title":"<code>qubit_approximant.benchmarking.plot.plot</code>","text":""},{"location":"reference/benchmarking/plot/plot/#qubit_approximant.benchmarking.plot.plot.box_plot_errores","title":"<code>box_plot_errores(layer_list, cost_array, function)</code>","text":"<p>Create a box plot for the seeds and metrics.</p> Source code in <code>qubit_approximant/benchmarking/plot/plot.py</code> <pre><code>def box_plot_errores(layer_list, cost_array, function):\n\"\"\"Create a box plot for the seeds and metrics.\"\"\"\n    fig, ax = plt.subplots(1, 2, figsize=(12, 6))\n    ax[0].boxplot(\n        cost_array,\n        meanline=True,\n        patch_artist=True,\n        medianprops={\"color\": \"crimson\", \"linewidth\": 1},\n        boxprops={\"facecolor\": \"lightsteelblue\", \"edgecolor\": \"black\", \"linewidth\": 0.5},\n    )\n\"\"\", positions=layer_list, widths=1.5, patch_artist=True,\n                showmeans=False, showfliers=False,\n                medianprops={\"color\": \"white\", \"linewidth\": 0.5},\n                boxprops={\"facecolor\": \"lightsteelblue\", \"edgecolor\": \"white\", \"linewidth\": 0.5},\n                whiskerprops={\"color\": \"C0\", \"linewidth\": 1.5})\"\"\"\n    ax[0].set_title(function)\n    ax[0].set_xlabel(\"Capas\")\n    ax[0].set_ylabel(\"Error\")\n    ax[0].set_yscale(\"log\")\n\n    violin = ax[1].violinplot(cost_array, showmeans=True, showmedians=True)\n    ax[1].set_title(function)\n    ax[1].set_xlabel(\"Capas\")\n    ax[1].set_xticks([y + 1 for y in range(cost_array.shape[1])])\n    ax[1].set_ylabel(\"Error\")\n    ax[1].set_yscale(\"log\")\n\n    violin[\"cmedians\"].set_color(\"crimson\")\n\n    plt.show()\n</code></pre>"},{"location":"reference/benchmarking/seeds/","title":"seeds","text":""},{"location":"reference/benchmarking/seeds/#qubit_approximant.benchmarking.seeds","title":"<code>qubit_approximant.benchmarking.seeds</code>","text":""},{"location":"reference/benchmarking/seeds/seeds/","title":"seeds","text":""},{"location":"reference/benchmarking/seeds/seeds/#qubit_approximant.benchmarking.seeds.seeds","title":"<code>qubit_approximant.benchmarking.seeds.seeds</code>","text":"<p>Benchmark our encoding and optimizer for multiple seeds.</p>"},{"location":"reference/benchmarking/seeds/seeds/#qubit_approximant.benchmarking.seeds.seeds.benchmark_seeds","title":"<code>benchmark_seeds(num_seeds, fn, fn_kwargs, circuit, cost, optimizer, filename)</code>","text":"<p>Benchmark a circuit ansatz, cost and multilayer optimizer for different seeds. The benchmarks are paralelized throught different nodes and cpu cores. The results are saved in a file in the order: layers_list, l1_list, l2_list, inf_list, infidelity_list; where each list contains the metric for each seed with every number of layers.</p> <p>Parameters:</p> Name Type Description Default <code>num_seeds</code> <code>int</code> <p>Number of seeds to benchmark.</p> required <code>fn</code> <code>Callable</code> <p>Function we want to approximate.</p> required <code>fn_kwargs</code> <code>dict</code> <p>Keyword arguments for 'fn'.</p> required <code>circuit</code> <code>Circuit</code> <p>Circuit ansatz used to encode the function.</p> required <code>cost</code> <code>Cost</code> <p>Cost or loss function used in the optimization to estimate the error in approximating fn using the quantum circuit.</p> required <code>optimizer</code> <code>MultilayerOptimizer</code> <p>Optimizer to obtain optimum parameters for multiple number of layers.</p> required <code>filename</code> <code>str</code> <p>File name to store the results (they may take some time).</p> required Source code in <code>qubit_approximant/benchmarking/seeds/seeds.py</code> <pre><code>def benchmark_seeds(\n    num_seeds: int,\n    fn: Callable,\n    fn_kwargs: dict,\n    circuit: Circuit,\n    cost: Cost,\n    optimizer: MultilayerOptimizer,\n    filename: str,\n) -&gt; None:\n\"\"\"Benchmark a circuit ansatz, cost and multilayer optimizer for different seeds.\n    The benchmarks are paralelized throught different nodes and cpu cores. The results\n    are saved in a file in the order:\n    layers_list, l1_list, l2_list, inf_list, infidelity_list;\n    where each list contains the metric for each seed with every number of layers.\n\n    Parameters\n    ----------\n    num_seeds : int\n        Number of seeds to benchmark.\n    fn : Callable\n        Function we want to approximate.\n    fn_kwargs : dict\n        Keyword arguments for 'fn'.\n    circuit : Circuit\n        Circuit ansatz used to encode the function.\n    cost : Cost\n        Cost or loss function used in the optimization to estimate the error\n        in approximating fn using the quantum circuit.\n    optimizer : MultilayerOptimizer\n        Optimizer to obtain optimum parameters for multiple number of layers.\n    filename : str\n        File name to store the results (they may take some time).\n    \"\"\"\n    opt = optimizer\n    num_layer = opt.max_layer - opt.min_layer + 1\n\n    print(\"Comienzan los c\u00e1lculos.\")\n\n    # dill allows to 'pickle' more complex objects\n    MPI.pickle.__init__(dill.dumps, dill.loads)  # type: ignore[misc]\n    comm = MPI.COMM_WORLD\n    num_nodes = comm.Get_size()\n    rank = comm.Get_rank()\n    seeds_node = num_seeds // num_nodes\n    rng = np.random.default_rng()\n    seed_list = rng.choice(range(rank * 2000, (rank + 1) * 2000), seeds_node, replace=False)\n\n    def metric_results_seed(seed: int) -&gt; Tuple[list[float], ...]:\n        rng = np.random.default_rng(seed)\n        params = opt.new_layer_coef * rng.standard_normal(circuit.params_layer * opt.min_layer)\n        params_list = opt(cost, cost.grad, params)\n        return metric_results(fn, fn_kwargs, circuit, params_list)\n\n    with ProcessingPool(cpu_count()) as p:\n        metrics_per_seed = p.map(metric_results_seed, seed_list)\n\n    print(\"C\u00e1lculos terminados.\")\n\n    l1_seeds = [metrics[0] for metrics in metrics_per_seed]\n    l2_seeds = [metrics[1] for metrics in metrics_per_seed]\n    inf_seeds = [metrics[2] for metrics in metrics_per_seed]\n    infidelity_seeds = [metrics[3] for metrics in metrics_per_seed]\n\n    metrics_send = np.array([l1_seeds, l2_seeds, inf_seeds, infidelity_seeds])\n    metrics_receive = None\n\n    if rank == 0:\n        # Receive data from the resting nodes\n        metrics_receive = np.zeros((num_nodes, len(metrics_send), seeds_node, num_layer))\n\n    # comm.Barrier()   # wait for everybody to synchronize _here_\n    comm.Gather(metrics_send, metrics_receive, root=0)  # Node 0 receives data\n    # comm.Barrier()\n\n    if rank == 0:\n        # dim results (nodes)x(metrics)x(seeds_node)x(layers)\n        metrics_receive = np.swapaxes(metrics_receive, 1, 2)  # type: ignore\n        # dim results (nodes)x(seeds_node)x(metrics)x(layers)\n        metrics = np.concatenate(metrics_receive, axis=0)\n        # dim results (seeds)x(metrics)x(layers)\n        metrics = np.swapaxes(metrics, 0, 1)\n        # dim results (metrics)x(seeds)x(layers)\n\n        layer_list = list(range(opt.min_layer, opt.max_layer + 1))\n\n        with open(filename + \".pkl\", \"wb\") as file:\n            pickle.dump(\n                (layer_list, metrics[0, ...], metrics[1, ...], metrics[2, ...], metrics[3, ...]),\n                file,\n            )\n</code></pre>"},{"location":"reference/core/","title":"core","text":""},{"location":"reference/core/#qubit_approximant.core","title":"<code>qubit_approximant.core</code>","text":""},{"location":"reference/core/#qubit_approximant.core.AdamOptimizer","title":"<code>AdamOptimizer(iters, step_size=0.01, beta1=0.9, beta2=0.999, eps=1e-08)</code>","text":"<p>         Bases: <code>GDOptimizer</code></p> <p>Adam (A Method for Stochastic Optimization) optimizer.</p> <p>Attributes:</p> Name Type Description <code>step_size</code> <code>float</code> <p>The size of the step of each gradient descent iteration.</p> <code>beta1</code> <code>float</code> <p>The factor for the average gradient.</p> <code>beta2</code> <code>float</code> <p>The factor for the average squared gradient.</p> <code>eps</code> <code>float</code> <p>A regularizing small parameter used to avoid division by zero.</p>"},{"location":"reference/core/#qubit_approximant.core.AdamOptimizer--references","title":"References","text":"<p>The optimizer is described in [1]_.</p> <p>.. [1] https://arxiv.org/abs/1412.6980</p> <p>iters : int     The number of gradient descent iterations to perform. step_size : float     The size of the step of each gradient descent iteration. beta1 : float     The factor for the average gradient. beta2 : float     The factor for the average squared gradient. eps: float     A regularizing small parameter used to avoid division by zero.</p> Source code in <code>qubit_approximant/core/optimizer/optimizer.py</code> <pre><code>def __init__(\n    self,\n    iters: int,\n    step_size: float = 0.01,\n    beta1: float = 0.9,\n    beta2: float = 0.999,\n    eps: float = 1e-8,\n):\n\"\"\"\n    Parameters\n    ----------\n    iters : int\n        The number of gradient descent iterations to perform.\n    step_size : float\n        The size of the step of each gradient descent iteration.\n    beta1 : float\n        The factor for the average gradient.\n    beta2 : float\n        The factor for the average squared gradient.\n    eps: float\n        A regularizing small parameter used to avoid division by zero.\n    \"\"\"\n    self.step_size = step_size\n    self.beta1 = beta1\n    self.beta2 = beta2\n    self.eps = eps\n    super().__init__(iters, step_size)\n</code></pre>"},{"location":"reference/core/#qubit_approximant.core.optimizer.optimizer.AdamOptimizer.step","title":"<code>step(grad_cost, params)</code>","text":"<p>Update the parameters with a step of Adam. Adam changes the step size in each iteration.</p> Source code in <code>qubit_approximant/core/optimizer/optimizer.py</code> <pre><code>def step(self, grad_cost: Callable, params: NDArray) -&gt; NDArray:\n\"\"\"Update the parameters with a step of Adam. Adam changes the step\n    size in each iteration.\"\"\"\n    m = zeros_like(params)\n    v = zeros_like(params)\n    grad = grad_cost(params)\n\n    m = self.beta1 * m + (1.0 - self.beta1) * grad\n    v = self.beta2 * v + (1.0 - self.beta2) * grad**2\n    mhat = m / (1.0 - self.beta1 ** (self.iter_index + 1))\n    vhat = v / (1.0 - self.beta2 ** (self.iter_index + 1))\n    params = params - self.step_size * mhat / (sqrt(vhat) + self.eps)\n\n    return params\n</code></pre>"},{"location":"reference/core/#qubit_approximant.core.BlackBoxOptimizer","title":"<code>BlackBoxOptimizer(method, method_kwargs=None)</code>","text":"<p>         Bases: <code>Optimizer</code></p> <p>Optimizer that uses scipy's inbuilt function <code>minimize</code>.</p> <p>Attributes:</p> Name Type Description <code>method</code> <code>str</code> <p>The desired optimization method.</p> <code>method_kwargs</code> <code>dict</code> <p>A dictionary with keyword arguments for the optimizer.</p> <p>Parameters:</p> Name Type Description Default <code>method</code> <code>str</code> <p>The desired optimization method.</p> required <code>method_kwargs</code> <code>dict</code> <p>A dictionary with keyword arguments for the optimizer.</p> <code>None</code> Source code in <code>qubit_approximant/core/optimizer/optimizer.py</code> <pre><code>def __init__(self, method: str, method_kwargs: dict | None = None):\n\"\"\"\n    Initialize a black box optimizer.\n\n    Parameters\n    ----------\n    method : str\n        The desired optimization method.\n    method_kwargs : dict\n        A dictionary with keyword arguments for the optimizer.\n    \"\"\"\n    if method in BlackBoxOptimizer.blackbox_methods:\n        self.method = method\n        self.method_kwargs = {} if method_kwargs is None else method_kwargs\n    else:\n        raise ValueError(f\"Optimization {method} is not supported.\")\n</code></pre>"},{"location":"reference/core/#qubit_approximant.core.optimizer.optimizer.BlackBoxOptimizer.__call__","title":"<code>__call__(cost, grad_cost, init_params)</code>","text":"<p>Calculate the optimized parameters using <code>scipy.optimize.minimize()</code>.</p> <p>Parameters:</p> Name Type Description Default <code>cost</code> <code>Callable</code> <p>Cost function to be minimized.</p> required <code>grad_cost</code> <code>Callable</code> <p>Gradient of the cost function.</p> required <code>init_params</code> <code>NDArray</code> <p>Initial parameter guess for the cost function; used to initialize the optimizer.</p> required <p>Returns:</p> Type Description <code>NDArray</code> <p>Optimum parameters</p> Source code in <code>qubit_approximant/core/optimizer/optimizer.py</code> <pre><code>def __call__(self, cost: Callable, grad_cost: Callable, init_params: NDArray) -&gt; NDArray:\n\"\"\"\n    Calculate the optimized parameters using `scipy.optimize.minimize()`.\n\n    Parameters\n    ----------\n    cost: Callable\n        Cost function to be minimized.\n    grad_cost: Callable\n        Gradient of the cost function.\n    init_params : NDArray\n        Initial parameter guess for the cost function; used to initialize the optimizer.\n\n    Returns\n    -------\n    NDArray\n        Optimum parameters\n    \"\"\"\n    result = minimize(\n        cost, init_params, method=self.method, jac=grad_cost, options=self.method_kwargs\n    )\n    params = result.x\n    return params\n</code></pre>"},{"location":"reference/core/#qubit_approximant.core.Circuit","title":"<code>Circuit(x, encoding, params_layer)</code>","text":"<p>         Bases: <code>ABC</code></p> <p>Quantum circuit that encodes the function. The circuit consists of a number of layers,</p> <p>U = Ln * ... * L1</p> <p>Attributes:</p> Name Type Description <code>encoding</code> <code>Callable</code> <p>Return the encoding of the function in the circuit. For example amplitude or probability of the |0&gt; qubit.</p> <code>grad_encoding</code> <code>Callable</code> <p>Returns the gradient of the chosen encoding.</p> <code>params_layer</code> <code>int</code> <p>Number of parameters per layer.</p> <p>x: NDArray     Values where to evaluate the function encoded in the circuit. encoding : str     Choose between amplitude or probability encoding.     Must be either 'amp' or 'prob'. params_layer : int     Number of parameters per layer.</p> Source code in <code>qubit_approximant/core/circuit/circuit.py</code> <pre><code>def __init__(self, x: NDArray, encoding: str, params_layer: int):\n\"\"\"\n    Parameters\n    ----------\n    x: NDArray\n        Values where to evaluate the function encoded in the circuit.\n    encoding : str\n        Choose between amplitude or probability encoding.\n        Must be either 'amp' or 'prob'.\n    params_layer : int\n        Number of parameters per layer.\n    \"\"\"\n    self.x = x\n\n    if encoding == \"prob\":\n        self.encoding = self.prob_encoding\n        self.grad_encoding = self.grad_prob\n    elif encoding == \"amp\":\n        self.encoding = self.amp_encoding\n        self.grad_encoding = self.grad_amp\n    else:\n        raise ValueError(\"Invalid encoding '{encoding}'. Choose between 'prob' or 'amp'.\")\n\n    self.params_layer = params_layer  # To be defined in subclasses\n</code></pre>"},{"location":"reference/core/#qubit_approximant.core.circuit.circuit.Circuit.x","title":"<code>x: NDArray</code>  <code>property</code> <code>writable</code>","text":"<p>Values where to evaluate the function encoded in the circuit.</p> <p>Returns:</p> Type Description <code>NDArray</code> <p>The value of x.</p>"},{"location":"reference/core/#qubit_approximant.core.circuit.circuit.Circuit.amp_encoding","title":"<code>amp_encoding(params)</code>","text":"<p>Returns approximate function encoded in the amplitude of the qubit.</p> <p>Parameters:</p> Name Type Description Default <code>params</code> <code>NDArray</code> <p>Parameters of the quantum gates in the layer.</p> required <p>Returns:</p> Type Description <code>NDArray</code> <p>Values of the amplitudes of the |0&gt; qubit for each value of x.</p> Source code in <code>qubit_approximant/core/circuit/circuit.py</code> <pre><code>def amp_encoding(self, params: NDArray) -&gt; NDArray:\n\"\"\"Returns approximate function encoded in the amplitude of the qubit.\n\n    Parameters\n    ----------\n    params : NDArray\n        Parameters of the quantum gates in the layer.\n\n    Returns\n    -------\n    NDArray\n        Values of the amplitudes of the |0&gt; qubit for each value of x.\n    \"\"\"\n    layers = params.size // self.params_layer\n    params = params.reshape(layers, self.params_layer)\n    U = self.layer(params[0, :])[:, :, 0]\n    for i in range(1, params.shape[0]):\n        Ui = self.layer(params[i, :])\n        U = np.einsum(\"gmn, gn -&gt; gm\", Ui, U)\n    return U[:, 0]\n</code></pre>"},{"location":"reference/core/#qubit_approximant.core.circuit.circuit.Circuit.grad_amp","title":"<code>grad_amp(params)</code>","text":"<p>Returns the gradient of the amplitude encoding and the encoded function.</p> <p>Parameters:</p> Name Type Description Default <code>params</code> <code>NDArray</code> <p>Parameters of the quantum gates in the layer.</p> required <p>Returns:</p> Type Description <code>tuple[NDArray, NDArray]</code> <p>Gradients of the amplitude with respect to all parameters and the amplitudes for each x.</p> Source code in <code>qubit_approximant/core/circuit/circuit.py</code> <pre><code>def grad_amp(self, params: NDArray) -&gt; tuple[NDArray, NDArray]:\n\"\"\"Returns the gradient of the amplitude encoding and the encoded function.\n\n    Parameters\n    ----------\n    params : NDArray\n        Parameters of the quantum gates in the layer.\n\n    Returns\n    -------\n    tuple[NDArray, NDArray]\n        Gradients of the amplitude with respect to all parameters and the amplitudes for each x.\n    \"\"\"\n    layers = params.size // self.params_layer\n    params = params.reshape(layers, self.params_layer)\n    U = np.tensordot(np.ones(self.x.size), np.array([1, 0]), axes=0)  # dim (G,2)\n    D = np.zeros((layers, self.params_layer, self.x.size, 2), dtype=np.complex128)\n\n    for i in range(layers):\n        DUi = self.grad_layer(params[i, :])  # dim (4,G,2)\n        # j is each of the derivatives\n        D[i, ...] = np.einsum(\"jgmn, gn -&gt; jgm\", DUi, U)\n        # Multiply derivative times next layer\n        Ui = self.layer(params[i, :])\n        U = np.einsum(\"gmn, gn -&gt; gm\", Ui, U)\n\n    grad = np.zeros((layers, self.params_layer, self.x.size), dtype=np.complex128)\n    grad[layers - 1] = D[layers - 1, :, :, 0]\n    # In the first iteration we reuse the L-th layer\n    B = Ui[:, 0, :]\n    for i in range(layers - 2, -1, -1):\n        grad[i, ...] = np.einsum(\"gm, jgm -&gt; jg\", B, D[i, ...])\n        # Multiply derivative times previous layer\n        Ui = self.layer(params[i, :])\n        B = np.einsum(\"gn, gnm -&gt; gm\", B, Ui)\n\n    grad = np.einsum(\"ijg -&gt; gij\", grad)\n    grad = grad.reshape(self.x.size, -1)  # D has shape (x, L*4)\n    fn_approx = U[:, 0]\n\n    return grad, fn_approx\n</code></pre>"},{"location":"reference/core/#qubit_approximant.core.circuit.circuit.Circuit.grad_layer","title":"<code>grad_layer(params)</code>  <code>abstractmethod</code>","text":"<p>Returns the derivative of one layer with respect to its parameters.</p> <p>Parameters:</p> Name Type Description Default <code>params</code> <code>NDArray</code> <p>Parameters of the quantum gates in the layer.</p> required <p>Returns:</p> Type Description <code>NDArray</code> <p>Values of the probabilities of the |0&gt; qubit for each value of x.</p> Source code in <code>qubit_approximant/core/circuit/circuit.py</code> <pre><code>@abstractmethod\ndef grad_layer(self, params: NDArray) -&gt; NDArray:\n\"\"\"Returns the derivative of one layer with respect to its parameters.\n\n    Parameters\n    ----------\n    params : NDArray\n        Parameters of the quantum gates in the layer.\n\n    Returns\n    -------\n    NDArray\n        Values of the probabilities of the |0&gt; qubit for each value of x.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/core/#qubit_approximant.core.circuit.circuit.Circuit.grad_prob","title":"<code>grad_prob(params)</code>","text":"<p>Returns the gradient of the probability encoding and the probability encoding.</p> <p>Parameters:</p> Name Type Description Default <code>params</code> <code>NDArray</code> <p>Parameters of the quantum gates in the layer.</p> required <p>Returns:</p> Type Description <code>tuple[NDArray, NDArray]</code> <p>Gradients of the probability with respect to all parameters and the probability for each x.</p> Source code in <code>qubit_approximant/core/circuit/circuit.py</code> <pre><code>def grad_prob(self, params: NDArray) -&gt; tuple[NDArray, NDArray]:\n\"\"\"Returns the gradient of the probability encoding and the probability encoding.\n\n    Parameters\n    ----------\n    params : NDArray\n        Parameters of the quantum gates in the layer.\n\n    Returns\n    -------\n    tuple[NDArray, NDArray]\n        Gradients of the probability with respect to all parameters\n        and the probability for each x.\n    \"\"\"\n    grad_amp, amp = self.grad_amp(params)\n    fn_approx = amp.real**2 + amp.imag**2\n    grad_prob = 2 * np.real(np.einsum(\"g, gi -&gt; gi\", amp.conj(), grad_amp))\n    return grad_prob, fn_approx\n</code></pre>"},{"location":"reference/core/#qubit_approximant.core.circuit.circuit.Circuit.layer","title":"<code>layer(params)</code>  <code>abstractmethod</code>","text":"<p>Returns the layer of our circuit</p> <p>Parameters:</p> Name Type Description Default <code>params</code> <code>NDArray</code> <p>Parameters of the quantum gates in the layer.</p> required <p>Returns:</p> Type Description <code>NDArray</code> <p>Unitary matrix of the layer with size (x,2,2)</p> Source code in <code>qubit_approximant/core/circuit/circuit.py</code> <pre><code>@abstractmethod\ndef layer(self, params: NDArray) -&gt; NDArray:\n\"\"\"Returns the layer of our circuit\n\n    Parameters\n    ----------\n    params : NDArray\n        Parameters of the quantum gates in the layer.\n\n    Returns\n    -------\n    NDArray\n        Unitary matrix of the layer with size (x,2,2)\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/core/#qubit_approximant.core.circuit.circuit.Circuit.prob_encoding","title":"<code>prob_encoding(params)</code>","text":"<p>Returns approximate function encoded in the probability of the qubit. s         Parameters         ----------         params : NDArray             Parameters of the quantum gates in the layer.</p> <pre><code>    Returns\n    -------\n    NDArray\n        Values of the probabilities of the |0&gt; qubit for each value of x.\n</code></pre> Source code in <code>qubit_approximant/core/circuit/circuit.py</code> <pre><code>def prob_encoding(self, params: NDArray) -&gt; NDArray:\n\"\"\"Returns approximate function encoded in the probability of the qubit.\n    s\n            Parameters\n            ----------\n            params : NDArray\n                Parameters of the quantum gates in the layer.\n\n            Returns\n            -------\n            NDArray\n                Values of the probabilities of the |0&gt; qubit for each value of x.\n    \"\"\"\n    fn_amp = self.amp_encoding(params)\n    return fn_amp.real**2 + fn_amp.imag**2\n</code></pre>"},{"location":"reference/core/#qubit_approximant.core.CircuitRxRy","title":"<code>CircuitRxRy(x, encoding)</code>","text":"<p>         Bases: <code>Circuit</code></p> <p>Each layer of the circuit is made of three rotations dependent on 3 parameters:</p> <p>L = RX(\u03b8x) RY(w * x + \u03b8y)</p> <p>x: NDArray     The values where we wish to approximate a function. encoding: str     Choose between amplitude or probability encoding.     Must be either 'amp' or 'prob'.</p> Source code in <code>qubit_approximant/core/circuit/circuit.py</code> <pre><code>def __init__(self, x: NDArray, encoding: str):\n\"\"\"\n    Parameters\n    ----------\n    x: NDArray\n        The values where we wish to approximate a function.\n    encoding: str\n        Choose between amplitude or probability encoding.\n        Must be either 'amp' or 'prob'.\n    \"\"\"\n    self.params_layer = 3\n    super().__init__(x, encoding, self.params_layer)\n</code></pre>"},{"location":"reference/core/#qubit_approximant.core.circuit.circuit.CircuitRxRy.grad_layer","title":"<code>grad_layer(params)</code>","text":"<p>Returns the derivative of one layer with respect to its 3 parameters.</p> <p>Parameters:</p> Name Type Description Default <code>params</code> <code>NDArray</code> <p>Parameters of the quantum gates in the layer.</p> required <p>Returns:</p> Type Description <code>NDArray</code> <p>Gradient of the layer with respect to each parameter.</p> Source code in <code>qubit_approximant/core/circuit/circuit.py</code> <pre><code>def grad_layer(self, params: NDArray) -&gt; NDArray:\n\"\"\"Returns the derivative of one layer with respect to its 3 parameters.\n\n    Parameters\n    ----------\n    params : NDArray\n        Parameters of the quantum gates in the layer.\n\n    Returns\n    -------\n    NDArray\n        Gradient of the layer with respect to each parameter.\n    \"\"\"\n    w = params[0]\n    \u03b8x = params[1]\n    \u03b8y = params[2]\n    Dx = np.einsum(\"mng, np -&gt; gmp\", RY(w * self.x + \u03b8y), grad_RX(\u03b8x))\n    Dy = np.einsum(\"mng, np -&gt; gmp\", grad_RY(w * self.x + \u03b8y), RX(\u03b8x))\n    Dw = np.einsum(\"gmn, g -&gt; gmn\", Dy, self.x)\n    return np.array([Dw, Dx, Dy])  # type: ignore\n</code></pre>"},{"location":"reference/core/#qubit_approximant.core.circuit.circuit.CircuitRxRy.layer","title":"<code>layer(params)</code>","text":"<p>Each layer is the product of two rotations. L = RX(\u03b8x) RY(w * x + \u03b8y)</p>"},{"location":"reference/core/#qubit_approximant.core.circuit.circuit.CircuitRxRy.layer--parmeters","title":"Parmeters","text":"<p>params : NDArray     Parameters of the gates in the layer.</p> <p>Returns:</p> Type Description <code>NDArray</code> <p>Unitary matrix of the layer with size (x,2,2)</p> <p>Raises:</p> Type Description <code>ParameterError</code> <p>The number of parameters given does not correspond with the circuit ansatz.</p> Source code in <code>qubit_approximant/core/circuit/circuit.py</code> <pre><code>def layer(self, params: NDArray) -&gt; NDArray:\n\"\"\"\n    Each layer is the product of two rotations.\n    L = RX(\u03b8x) RY(w * x + \u03b8y)\n\n    Parmeters\n    ---------\n    params : NDArray\n        Parameters of the gates in the layer.\n\n    Returns\n    -------\n    NDArray\n        Unitary matrix of the layer with size (x,2,2)\n\n    Raises\n    ------\n    ParameterError\n        The number of parameters given does not correspond with\n        the circuit ansatz.\n    \"\"\"\n    if params.size != self.params_layer:\n        raise ParameterError(self.params_layer)\n    w = params[0]\n    \u03b8x = params[1]\n    \u03b8y = params[2]\n    # move the x axis to first position\n    return np.einsum(\"mng, np -&gt; gmp\", RY(w * self.x + \u03b8y), RX(\u03b8x))\n</code></pre>"},{"location":"reference/core/#qubit_approximant.core.CircuitRxRyRz","title":"<code>CircuitRxRyRz(x, encoding)</code>","text":"<p>         Bases: <code>Circuit</code></p> <p>Each layer of the circuit is made of three rotations dependent on 4 parameters:</p> <p>L = RX(x * w + \u03b8x) RY(\u03b8y) RZ(\u03b8z)</p> <p>x: NDArray     The values where we wish to approximate a function. encoding: str     Choose between amplitude or probability encoding.     Must be either 'amp' or 'prob'.</p> Source code in <code>qubit_approximant/core/circuit/circuit.py</code> <pre><code>def __init__(self, x: NDArray, encoding: str):\n\"\"\"\n    Parameters\n    ----------\n    x: NDArray\n        The values where we wish to approximate a function.\n    encoding: str\n        Choose between amplitude or probability encoding.\n        Must be either 'amp' or 'prob'.\n    \"\"\"\n    self.params_layer = 4\n    super().__init__(x, encoding, self.params_layer)\n</code></pre>"},{"location":"reference/core/#qubit_approximant.core.circuit.circuit.CircuitRxRyRz.grad_layer","title":"<code>grad_layer(params)</code>","text":"<p>Returns the derivative of one layer with respect to its 4 parameters.</p> <p>Parameters:</p> Name Type Description Default <code>params</code> <code>NDArray</code> <p>Parameters of the quantum gates in the layer.</p> required <p>Returns:</p> Type Description <code>NDArray</code> <p>Gradient of the layer with respect to each parameter.</p> Source code in <code>qubit_approximant/core/circuit/circuit.py</code> <pre><code>def grad_layer(self, params: NDArray) -&gt; NDArray:\n\"\"\"Returns the derivative of one layer with respect to its 4 parameters.\n\n    Parameters\n    ----------\n    params : NDArray\n        Parameters of the quantum gates in the layer.\n\n    Returns\n    -------\n    NDArray\n        Gradient of the layer with respect to each parameter.\n    \"\"\"\n    w = params[0]\n    \u03b8x = params[1]\n    \u03b8y = params[2]\n    \u03b8z = params[3]\n\n    Dx = np.einsum(\"mn, np, pqg -&gt; gmq\", RZ(\u03b8z), RY(\u03b8y), grad_RX(w * self.x + \u03b8x))\n    Dw = np.einsum(\"gmq, g -&gt; gmq\", Dx, self.x)\n    Dy = np.einsum(\"mn, np, pqg -&gt; gmq\", RZ(\u03b8z), grad_RY(\u03b8y), RX(w * self.x + \u03b8x))\n    Dz = np.einsum(\"mn, np, pqg -&gt; gmq\", grad_RZ(\u03b8z), RY(\u03b8y), RX(w * self.x + \u03b8x))\n\n    return np.array([Dw, Dx, Dy, Dz])  # type: ignore\n</code></pre>"},{"location":"reference/core/#qubit_approximant.core.circuit.circuit.CircuitRxRyRz.layer","title":"<code>layer(params)</code>","text":"<p>Returns the layer of the circuit: L = RX(x * w + \u03b80) RY(\u03b81) RZ(\u03b82)</p> <p>Parameters:</p> Name Type Description Default <code>params</code> <code>NDArray</code> <p>Parameters of the quantum gates in the layer.</p> required <p>Returns:</p> Type Description <code>NDArray</code> <p>Unitary matrix of the layer with size (x,2,2)</p> <p>Raises:</p> Type Description <code>ParameterError</code> <p>The number of parameters given does not correspond with the circuit ansatz.</p> Source code in <code>qubit_approximant/core/circuit/circuit.py</code> <pre><code>def layer(self, params: NDArray) -&gt; NDArray:\n\"\"\"\n    Returns the layer of the circuit:\n    L = RX(x * w + \u03b80) RY(\u03b81) RZ(\u03b82)\n\n    Parameters\n    ----------\n    params : NDArray\n        Parameters of the quantum gates in the layer.\n\n    Returns\n    -------\n    NDArray\n        Unitary matrix of the layer with size (x,2,2)\n\n    Raises\n    ------\n    ParameterError\n        The number of parameters given does not correspond with\n        the circuit ansatz.\n    \"\"\"\n    if params.size != self.params_layer:\n        raise ParameterError(self.params_layer)\n    w = params[0]\n    \u03b8x = params[1]\n    \u03b8y = params[2]\n    \u03b8z = params[3]\n    # move the x axis to first position\n    return np.einsum(\"mn, np, pqg -&gt; gmq\", RZ(\u03b8z), RY(\u03b8y), RX(w * self.x + \u03b8x))\n</code></pre>"},{"location":"reference/core/#qubit_approximant.core.CircuitRy","title":"<code>CircuitRy(x, encoding)</code>","text":"<p>         Bases: <code>Circuit</code></p> <p>Each layer of the circuit is made of three rotations dependent on 2 parameters:</p> <p>L = RY(w * x + \u03b8y)</p> <p>x: NDArray     The values where we wish to approximate a function. encoding: str     Choose between amplitude or probability encoding.     Must be either 'amp' or 'prob'.</p> Source code in <code>qubit_approximant/core/circuit/circuit.py</code> <pre><code>def __init__(self, x: NDArray, encoding: str):\n\"\"\"\n    Parameters\n    ----------\n    x: NDArray\n        The values where we wish to approximate a function.\n    encoding: str\n        Choose between amplitude or probability encoding.\n        Must be either 'amp' or 'prob'.\n    \"\"\"\n    self.params_layer = 2\n    super().__init__(x, encoding, self.params_layer)\n</code></pre>"},{"location":"reference/core/#qubit_approximant.core.circuit.circuit.CircuitRy.grad_layer","title":"<code>grad_layer(params)</code>","text":"<p>Returns the derivative of one layer with respect to its 2 parameters.</p> <p>Parameters:</p> Name Type Description Default <code>params</code> <code>NDArray</code> <p>Parameters of the quantum gates in the layer.</p> required <p>Returns:</p> Type Description <code>NDArray</code> <p>Gradient of the layer with respect to each parameter.</p> Source code in <code>qubit_approximant/core/circuit/circuit.py</code> <pre><code>def grad_layer(self, params: NDArray) -&gt; NDArray:\n\"\"\"Returns the derivative of one layer with respect to its 2 parameters.\n\n    Parameters\n    ----------\n    params : NDArray\n        Parameters of the quantum gates in the layer.\n\n    Returns\n    -------\n    NDArray\n        Gradient of the layer with respect to each parameter.\n    \"\"\"\n    w = params[0]\n    \u03b8y = params[1]\n    Dy = np.einsum(\"mng -&gt; gmn\", grad_RY(w * self.x + \u03b8y))\n    Dw = np.einsum(\"gmn, g -&gt; gmn\", Dy, self.x)\n\n    return np.array([Dw, Dy])  # type: ignore\n</code></pre>"},{"location":"reference/core/#qubit_approximant.core.circuit.circuit.CircuitRy.layer","title":"<code>layer(params)</code>","text":"<p>Each layer is one RY rotation: L = RY(w * x + \u03b8y)</p>"},{"location":"reference/core/#qubit_approximant.core.circuit.circuit.CircuitRy.layer--parmeters","title":"Parmeters","text":"<p>params : NDArray     Parameters of the gates in the layer.</p> <p>Returns:</p> Type Description <code>NDArray</code> <p>Unitary matrix of the layer with size (x,2,2)</p> <p>Raises:</p> Type Description <code>ParameterError</code> <p>The number of parameters given does not correspond with the circuit ansatz.</p> Source code in <code>qubit_approximant/core/circuit/circuit.py</code> <pre><code>def layer(self, params: NDArray) -&gt; NDArray:\n\"\"\"\n    Each layer is one RY rotation:\n    L = RY(w * x + \u03b8y)\n\n    Parmeters\n    ---------\n    params : NDArray\n        Parameters of the gates in the layer.\n\n    Returns\n    -------\n    NDArray\n        Unitary matrix of the layer with size (x,2,2)\n\n    Raises\n    ------\n    ParameterError\n        The number of parameters given does not correspond with\n        the circuit ansatz.\n    \"\"\"\n    if params.size != self.params_layer:\n        raise ParameterError(self.params_layer)\n    w = params[0]\n    \u03b8y = params[1]\n    # move the x axis to first position\n    return np.einsum(\"mng -&gt; gmn\", RY(w * self.x + \u03b8y))\n</code></pre>"},{"location":"reference/core/#qubit_approximant.core.Cost","title":"<code>Cost(fn, circuit, metric)</code>","text":"<p>Create a cost function from the encoding and the metric.</p> <p>Attributes:</p> Name Type Description <code>metric</code> <code>Callable</code> <p>The metric or loss function to quantify how well our circuit approximates the target function.</p> <code>grad_metric</code> <code>Callable</code> <p>The gradient of the metric or loss function.</p> <code>circuit</code> <code>Circuit</code> <p>Quantum circuit that encodes our function.</p> <code>fn</code> <code>NDArray</code> <p>Function we desire to approximate.</p> <p>fn : NDArray     Function we desire to approximate. circuit : Circuit     Quantum circuit that encodes our function. metric : str     Name of the metric we want to use.     Allowed values are:         - 'mse' (mean square error)         - 'rmse' (root mean square error)         - 'mse_weighted' (mse weighted by fn)         - 'kl_divergence'         - 'log_cosh'.</p> Source code in <code>qubit_approximant/core/cost/cost.py</code> <pre><code>def __init__(self, fn: NDArray, circuit: Circuit, metric: str) -&gt; None:\n\"\"\"\n    Parameters\n    ----------\n    fn : NDArray\n        Function we desire to approximate.\n    circuit : Circuit\n        Quantum circuit that encodes our function.\n    metric : str\n        Name of the metric we want to use.\n        Allowed values are:\n            - 'mse' (mean square error)\n            - 'rmse' (root mean square error)\n            - 'mse_weighted' (mse weighted by fn)\n            - 'kl_divergence'\n            - 'log_cosh'.\n    \"\"\"\n    try:\n        self.metric = globals()[metric]\n        self.grad_metric = globals()[\"grad_\" + metric]\n    except KeyError as e:\n        raise ValueError(\"Invalid metric '{metric}'. Choose between 'MSE' or 'RMSE'.\") from e\n\n    self.circuit = circuit\n    self.fn = fn\n</code></pre>"},{"location":"reference/core/#qubit_approximant.core.cost.cost.Cost.__call__","title":"<code>__call__(params)</code>","text":"<p>Evaluate the cost function given the parameters of the circuit.</p> <p>Parameters:</p> Name Type Description Default <code>params</code> <code>NDArray</code> <p>Parameters of the quantum gates in the layer.</p> required <p>Returns:</p> Type Description <code>float</code> <p>The value of the cost function for the chosen circuit and metric.</p> Source code in <code>qubit_approximant/core/cost/cost.py</code> <pre><code>def __call__(self, params: NDArray) -&gt; float:\n\"\"\"Evaluate the cost function given the parameters of the circuit.\n\n    Parameters\n    ----------\n    params : NDArray\n        Parameters of the quantum gates in the layer.\n\n    Returns\n    -------\n    float\n        The value of the cost function for the chosen circuit and metric.\n    \"\"\"\n    fn_approx = self.circuit.encoding(params)\n    return self.metric(self.fn, fn_approx)\n</code></pre>"},{"location":"reference/core/#qubit_approximant.core.cost.cost.Cost.grad","title":"<code>grad(params)</code>","text":"<p>Return the gradient of the cost function.</p> <p>Parameters:</p> Name Type Description Default <code>params</code> <code>NDArray</code> <p>Parameters of the quantum gates in the layer.</p> required <p>Returns:</p> Type Description <code>NDArray</code> <p>Gradient of the cost.</p> Source code in <code>qubit_approximant/core/cost/cost.py</code> <pre><code>def grad(self, params: NDArray) -&gt; NDArray:\n\"\"\"Return the gradient of the cost function.\n\n    Parameters\n    ----------\n    params : NDArray\n        Parameters of the quantum gates in the layer.\n\n    Returns\n    -------\n    NDArray\n        Gradient of the cost.\n    \"\"\"\n    grad_fn_approx, fn_approx = self.circuit.grad_encoding(params)\n    return self.grad_metric(self.fn, fn_approx, grad_fn_approx)\n</code></pre>"},{"location":"reference/core/#qubit_approximant.core.GDOptimizer","title":"<code>GDOptimizer(iters, step_size)</code>","text":"<p>         Bases: <code>Optimizer</code></p> <p>Gradient descent optimizer.</p> <p>iters : int     The number of gradient descent iterations to perform. step_size : float     The size of the step of each gradient descent iteration.</p> Source code in <code>qubit_approximant/core/optimizer/optimizer.py</code> <pre><code>def __init__(self, iters: int, step_size: float):\n\"\"\"\n    Parameters\n    ----------\n    iters : int\n        The number of gradient descent iterations to perform.\n    step_size : float\n        The size of the step of each gradient descent iteration.\n    \"\"\"\n    self.step_size = step_size\n    self._iters = iters\n</code></pre>"},{"location":"reference/core/#qubit_approximant.core.optimizer.optimizer.GDOptimizer.iters","title":"<code>iters</code>  <code>property</code> <code>writable</code>","text":"<p>Number of iterations of gradient descent.</p>"},{"location":"reference/core/#qubit_approximant.core.optimizer.optimizer.GDOptimizer.__call__","title":"<code>__call__(cost, grad_cost, params)</code>","text":"<p>Calculate the optimized parameters using a number of gradient descent iterations.</p> <p>Parameters:</p> Name Type Description Default <code>cost</code> <code>Callable</code> <p>Cost function to be minimized.</p> required <code>grad_cost</code> <code>Callable</code> <p>Gradient of the cost function.</p> required <code>params</code> <code>NDArray</code> <p>Initial parameter guess for the cost function; used to initialize the optimizer.</p> required <p>Returns:</p> Type Description <code>NDArray</code> <p>Optimum parameters</p> Source code in <code>qubit_approximant/core/optimizer/optimizer.py</code> <pre><code>def __call__(self, cost: Callable, grad_cost: Callable, params: NDArray) -&gt; NDArray:\n\"\"\"\n    Calculate the optimized parameters using a number of gradient descent iterations.\n\n    Parameters\n    ----------\n    cost : Callable\n        Cost function to be minimized.\n    grad_cost : Callable\n        Gradient of the cost function.\n    params : NDArray\n        Initial parameter guess for the cost function; used to initialize the optimizer.\n\n    Returns\n    -------\n    NDArray\n        Optimum parameters\n    \"\"\"\n    min_cost = 100000\n    min_params = zeros_like(params)\n\n    for i in range(self.iters):\n        self.iter_index = i\n        params = self.step(grad_cost, params)\n\n        if (c := cost(params)) &lt; min_cost:\n            self.min_cost = c\n            min_params = params\n\n    return min_params\n</code></pre>"},{"location":"reference/core/#qubit_approximant.core.optimizer.optimizer.GDOptimizer.step","title":"<code>step(grad_cost, params)</code>","text":"<p>Update the parameters with a step of Gradient Descent.</p> Source code in <code>qubit_approximant/core/optimizer/optimizer.py</code> <pre><code>def step(self, grad_cost: Callable, params: NDArray) -&gt; NDArray:\n\"\"\"Update the parameters with a step of Gradient Descent.\"\"\"\n    params = params - grad_cost(params) * self.step_size\n    return params\n</code></pre>"},{"location":"reference/core/#qubit_approximant.core.IncrementalOptimizer","title":"<code>IncrementalOptimizer(min_layer, max_layer, optimizer, new_layer_coef, new_layer_position)</code>","text":"<p>         Bases: <code>MultilayerOptimizer</code></p> <p>This optimizer uses the parameters of an optimized L layer circuit as input for the optimization of a L+1 layer circuit.</p> <p>Attributes:</p> Name Type Description <code>new_layer_position</code> <code>str</code> <p>The position where to add the parameters of the new layer. For, example, it may be the initial or final layer of our circuit.</p> <p>Parameters:</p> Name Type Description Default <code>min_layer</code> <code>int</code> <p>Starting number of layers to optimize.</p> required <code>max_layer</code> <code>int</code> <p>Final number of layers to optimize.</p> required <code>optimizer</code> <code>Optimizer</code> <p>The optimizer used to find the optimum parameters.</p> required <code>new_layer_coef</code> <code>float</code> <p>The coefficient that multiplies the normal distribution of the new parameters in the additional layer.</p> required <code>new_layer_position</code> <code>str</code> <p>The position where to add the parameters of the new layer. For, example, it may be the initial or final layer of our circuit.</p> required Source code in <code>qubit_approximant/core/optimizer/multilayer_optimizer.py</code> <pre><code>def __init__(\n    self,\n    min_layer,\n    max_layer,\n    optimizer: Optimizer,\n    new_layer_coef: float,\n    new_layer_position: str,\n) -&gt; None:\n\"\"\"\n    Initialize a black box optimizer.\n\n    Parameters\n    ----------\n    min_layer : int\n        Starting number of layers to optimize.\n    max_layer : int\n        Final number of layers to optimize.\n    optimizer : Optimizer\n        The optimizer used to find the optimum parameters.\n    new_layer_coef : float\n        The coefficient that multiplies the normal distribution of the\n        new parameters in the additional layer.\n    new_layer_position : str\n        The position where to add the parameters of the new layer. For,\n        example, it may be the initial or final layer of our circuit.\n    \"\"\"\n    if new_layer_position in IncrementalOptimizer.layer_positions:\n        self.new_layer_position = new_layer_position\n    else:\n        raise ValueError(\n            f\"new_layer_position = {new_layer_position} is not supported. \"\n            \"Try 'initial', 'middle', 'final' or 'random'\"\n        )\n    super().__init__(min_layer, max_layer, optimizer, new_layer_coef)\n</code></pre>"},{"location":"reference/core/#qubit_approximant.core.optimizer.multilayer_optimizer.IncrementalOptimizer.inital_params_diff","title":"<code>inital_params_diff: tuple[list[float], list[float]]</code>  <code>property</code>","text":"<p>Returns a list with the mean and standard deviation of the difference between the optimum parameters in the i-th layer and the optimum parameters of the (i+1)-th layer. (We exclude the additional parameters added with the new layer).</p> <p>Returns:</p> Type Description <code>tuple[list[float], list[float]]</code> <p>Mean and standard deviation of the parameter differences.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>Parameter difference only supported for new initial and final layers.</p>"},{"location":"reference/core/#qubit_approximant.core.optimizer.multilayer_optimizer.IncrementalOptimizer.__call__","title":"<code>__call__(cost, grad_cost, init_params)</code>","text":"<p>Calculate the optimized parameters for each number of layers.</p> <p>Parameters:</p> Name Type Description Default <code>cost</code> <code>Callable</code> <p>Cost function to be minimized.</p> required <code>grad_cost</code> <code>Callable</code> <p>Gradient of the cost function.</p> required <code>init_params</code> <code>NDArray</code> <p>Initial parameter guess for the cost function; used to initialize the optimizer.</p> required <p>Returns:</p> Type Description <code>list[NDArray]</code> <p>The optimum parameters for each number of layers.</p> Source code in <code>qubit_approximant/core/optimizer/multilayer_optimizer.py</code> <pre><code>def __call__(self, cost: Callable, grad_cost: Callable, init_params: NDArray) -&gt; list[NDArray]:\n\"\"\"Calculate the optimized parameters for each number of layers.\n\n    Parameters\n    ----------\n    cost : Callable\n        Cost function to be minimized.\n    grad_cost : Callable\n        Gradient of the cost function.\n    init_params : NDArray\n        Initial parameter guess for the cost function; used to initialize the optimizer.\n\n    Returns\n    -------\n    list[NDArray]\n        The optimum parameters for each number of layers.\n    \"\"\"\n    self.params_layer = init_params.size // self.min_layer\n    params = init_params\n    self.params_list = []\n\n    for layer in range(self.min_layer, self.max_layer + 1):\n        params = self.optimizer(cost, grad_cost, params)\n        self.params_list.append(params)\n        params = self._new_initial_params(params, layer)\n    return self.params_list\n</code></pre>"},{"location":"reference/core/#qubit_approximant.core.MultilayerOptimizer","title":"<code>MultilayerOptimizer(min_layer, max_layer, optimizer, new_layer_coef=0.3)</code>","text":"<p>         Bases: <code>ABC</code></p> <p>This optimizer uses the parameters of an optimized L layer circuit as input for the optimization of a L+1 layer circuit.</p> <p>Attributes:</p> Name Type Description <code>min_layer</code> <code>int</code> <p>Starting number of layers to optimize.</p> <code>max_layer</code> <code>int</code> <p>Final number of layers to optimize.</p> <code>optimizer</code> <code>Optimizer</code> <p>The optimizer used to find the optimum parameters.</p> <code>new_layer_coef</code> <code>float</code> <p>The coefficient that multiplies the normal distribution of the new parameters in the additional layer.</p> <p>Parameters:</p> Name Type Description Default <code>min_layer</code> <code>int</code> <p>Starting number of layers to optimize.</p> required <code>max_layer</code> <code>int</code> <p>Final number of layers to optimize.</p> required <code>optimizer</code> <code>Optimizer</code> <p>The optimizer used to find the optimum parameters.</p> required <code>new_layer_coef</code> <code>float</code> <p>The coefficient that multiplies the normal distribution of the new parameters in the additional layer.</p> <code>0.3</code> Source code in <code>qubit_approximant/core/optimizer/multilayer_optimizer.py</code> <pre><code>def __init__(self, min_layer, max_layer, optimizer: Optimizer, new_layer_coef: float = 0.3):\n\"\"\"\n    Initialize a black box optimizer.\n\n    Parameters\n    ----------\n    min_layer : int\n        Starting number of layers to optimize.\n    max_layer : int\n        Final number of layers to optimize.\n    optimizer : Optimizer\n        The optimizer used to find the optimum parameters.\n    new_layer_coef : float\n        The coefficient that multiplies the normal distribution of the\n        new parameters in the additional layer.\n    \"\"\"\n    self.min_layer = min_layer\n    self.max_layer = max_layer\n    self.optimizer = optimizer\n    self.new_layer_coef = new_layer_coef\n</code></pre>"},{"location":"reference/core/#qubit_approximant.core.optimizer.multilayer_optimizer.MultilayerOptimizer.__call__","title":"<code>__call__(cost, grad_cost, init_params)</code>  <code>abstractmethod</code>","text":"<p>Calculate the optimized parameters for each number of layers.</p> <p>Parameters:</p> Name Type Description Default <code>cost</code> <code>Callable</code> <p>Cost function to be minimized.</p> required <code>grad_cost</code> <code>Callable</code> <p>Gradient of the cost function.</p> required <code>init_params</code> <code>NDArray</code> <p>Initial parameter guess for the cost function; used to initialize the optimizer.</p> required <p>Returns:</p> Type Description <code>list of NDArray</code> <p>The optimum parameters for each number of layers.</p> Source code in <code>qubit_approximant/core/optimizer/multilayer_optimizer.py</code> <pre><code>@abstractmethod\ndef __call__(self, cost: Callable, grad_cost: Callable, init_params: NDArray) -&gt; list[NDArray]:\n\"\"\"\n    Calculate the optimized parameters for each number of layers.\n\n    Parameters\n    ----------\n    cost: Callable\n        Cost function to be minimized.\n    grad_cost: Callable\n        Gradient of the cost function.\n    init_params : NDArray\n        Initial parameter guess for the cost function; used to initialize the optimizer.\n\n    Returns\n    -------\n    list of NDArray\n        The optimum parameters for each number of layers.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/core/#qubit_approximant.core.NonIncrementalOptimizer","title":"<code>NonIncrementalOptimizer(min_layer, max_layer, optimizer, new_layer_coef)</code>","text":"<p>         Bases: <code>MultilayerOptimizer</code></p> <p>This optimizer creates new initial parameters for the optimization of a circuit with an additional layer.</p> <p>Parameters:</p> Name Type Description Default <code>min_layer</code> <code>int</code> <p>Starting number of layers to optimize.</p> required <code>max_layer</code> <code>int</code> <p>Final number of layers to optimize.</p> required <code>optimizer</code> <code>Optimizer</code> <p>The optimizer used to find the optimum parameters.</p> required <code>new_layer_coef</code> <code>float</code> <p>The coefficient that multiplies the normal distribution of the new parameters in the additional layer.</p> required Source code in <code>qubit_approximant/core/optimizer/multilayer_optimizer.py</code> <pre><code>def __init__(self, min_layer, max_layer, optimizer: Optimizer, new_layer_coef: float):\n\"\"\"\n    Initialize a black box optimizer.\n\n    Parameters\n    ----------\n    min_layer : int\n        Starting number of layers to optimize.\n    max_layer : int\n        Final number of layers to optimize.\n    optimizer : Optimizer\n        The optimizer used to find the optimum parameters.\n    new_layer_coef : float\n        The coefficient that multiplies the normal distribution of the\n        new parameters in the additional layer.\n    \"\"\"\n    super().__init__(min_layer, max_layer, optimizer, new_layer_coef)\n</code></pre>"},{"location":"reference/core/#qubit_approximant.core.optimizer.multilayer_optimizer.NonIncrementalOptimizer.__call__","title":"<code>__call__(cost, grad_cost, init_params)</code>","text":"<p>Calculate the optimized parameters for each number of layers.</p> <p>Parameters:</p> Name Type Description Default <code>cost</code> <code>Callable</code> <p>Cost function to be minimized.</p> required <code>grad_cost</code> <code>Callable</code> <p>Gradient of the cost function.</p> required <code>init_params</code> <code>NDArray</code> <p>Initial parameter guess for the cost function; used to initialize the optimizer.</p> required <p>Returns:</p> Type Description <code>list[NDArray]</code> <p>The optimum parameters for each number of layers.</p> Source code in <code>qubit_approximant/core/optimizer/multilayer_optimizer.py</code> <pre><code>def __call__(self, cost: Callable, grad_cost: Callable, init_params: NDArray) -&gt; list[NDArray]:\n\"\"\"\n    Calculate the optimized parameters for each number of layers.\n\n    Parameters\n    ----------\n    cost: Callable\n        Cost function to be minimized.\n    grad_cost: Callable\n        Gradient of the cost function.\n    init_params : NDArray\n        Initial parameter guess for the cost function; used to initialize the optimizer.\n\n    Returns\n    -------\n    list[NDArray]\n        The optimum parameters for each number of layers.\n    \"\"\"\n    self.params_layer = init_params.size // self.min_layer\n    self.params_list = []\n    params = init_params\n    rng = np.random.default_rng()\n\n    for layer in range(self.min_layer, self.max_layer + 1):\n        params = self.optimizer(cost, grad_cost, params)\n        self.params_list.append(params)\n        params = self.new_layer_coef * rng.standard_normal((layer + 1) * self.params_layer)\n    return self.params_list\n</code></pre>"},{"location":"reference/core/circuit/","title":"circuit","text":""},{"location":"reference/core/circuit/#qubit_approximant.core.circuit","title":"<code>qubit_approximant.core.circuit</code>","text":""},{"location":"reference/core/circuit/_gates_and_grads/","title":"_gates_and_grads","text":""},{"location":"reference/core/circuit/_gates_and_grads/#qubit_approximant.core.circuit._gates_and_grads","title":"<code>qubit_approximant.core.circuit._gates_and_grads</code>","text":"<p>Gates for our quantum circuit.</p>"},{"location":"reference/core/circuit/_gates_and_grads/#qubit_approximant.core.circuit._gates_and_grads.RX","title":"<code>RX(angle)</code>","text":"<p>Rotation around X axis.</p> Source code in <code>qubit_approximant/core/circuit/_gates_and_grads.py</code> <pre><code>def RX(angle: float) -&gt; NDArray:\n\"\"\"Rotation around X axis.\"\"\"\n    return np.array(\n        [[cos(angle / 2), -1j * sin(angle / 2)], [-1j * sin(angle / 2), cos(angle / 2)]]\n    )\n</code></pre>"},{"location":"reference/core/circuit/_gates_and_grads/#qubit_approximant.core.circuit._gates_and_grads.RY","title":"<code>RY(angle)</code>","text":"<p>Rotation around Y axis.</p> Source code in <code>qubit_approximant/core/circuit/_gates_and_grads.py</code> <pre><code>def RY(angle: float) -&gt; NDArray:\n\"\"\"Rotation around Y axis.\"\"\"\n    return np.array([[cos(angle / 2), -sin(angle / 2)], [sin(angle / 2), cos(angle / 2)]])\n</code></pre>"},{"location":"reference/core/circuit/_gates_and_grads/#qubit_approximant.core.circuit._gates_and_grads.RZ","title":"<code>RZ(angle)</code>","text":"<p>Rotation around Z axis.</p> Source code in <code>qubit_approximant/core/circuit/_gates_and_grads.py</code> <pre><code>def RZ(angle: float) -&gt; NDArray:\n\"\"\"Rotation around Z axis.\"\"\"\n    return np.array(\n        [[cos(angle / 2) - 1j * sin(angle / 2), 0], [0, cos(angle / 2) + 1j * sin(angle / 2)]]\n    )\n</code></pre>"},{"location":"reference/core/circuit/_gates_and_grads/#qubit_approximant.core.circuit._gates_and_grads.grad_RX","title":"<code>grad_RX(angle)</code>","text":"<p>Derivative of the rotation around X axis.</p> Source code in <code>qubit_approximant/core/circuit/_gates_and_grads.py</code> <pre><code>def grad_RX(angle: float) -&gt; NDArray:\n\"\"\"Derivative of the rotation around X axis.\"\"\"\n    return 0.5 * np.array(\n        [[-sin(angle / 2), -1j * cos(angle / 2)], [-1j * cos(angle / 2), -sin(angle / 2)]]\n    )\n</code></pre>"},{"location":"reference/core/circuit/_gates_and_grads/#qubit_approximant.core.circuit._gates_and_grads.grad_RY","title":"<code>grad_RY(angle)</code>","text":"<p>Derivative of the rotation around Y axis.</p> Source code in <code>qubit_approximant/core/circuit/_gates_and_grads.py</code> <pre><code>def grad_RY(angle: float) -&gt; NDArray:\n\"\"\"Derivative of the rotation around Y axis.\"\"\"\n    return 0.5 * np.array([[-sin(angle / 2), -cos(angle / 2)], [cos(angle / 2), -sin(angle / 2)]])\n</code></pre>"},{"location":"reference/core/circuit/_gates_and_grads/#qubit_approximant.core.circuit._gates_and_grads.grad_RZ","title":"<code>grad_RZ(angle)</code>","text":"<p>Derivative of the rotation around Z axis.</p> Source code in <code>qubit_approximant/core/circuit/_gates_and_grads.py</code> <pre><code>def grad_RZ(angle: float) -&gt; NDArray:\n\"\"\"Derivative of the rotation around Z axis.\"\"\"\n    return 0.5 * np.array(\n        [[-1j * cos(angle / 2) - sin(angle / 2), 0], [0, 1j * cos(angle / 2) - sin(angle / 2)]]\n    )\n</code></pre>"},{"location":"reference/core/circuit/circuit/","title":"circuit","text":""},{"location":"reference/core/circuit/circuit/#qubit_approximant.core.circuit.circuit","title":"<code>qubit_approximant.core.circuit.circuit</code>","text":"<p>Module docstrings</p>"},{"location":"reference/core/circuit/circuit/#qubit_approximant.core.circuit.circuit--classes","title":"Classes","text":"<p>Circuit: abstract class, it is the basis of our specific circuit classes. CircuitRxRyRz: each layer is composed of three rotations CircuitRxRy: each layer is composed of RX and RY rotation CircuitRy: each layer is composed of just one RY rotation</p>"},{"location":"reference/core/circuit/circuit/#qubit_approximant.core.circuit.circuit.Circuit","title":"<code>Circuit(x, encoding, params_layer)</code>","text":"<p>         Bases: <code>ABC</code></p> <p>Quantum circuit that encodes the function. The circuit consists of a number of layers,</p> <p>U = Ln * ... * L1</p> <p>Attributes:</p> Name Type Description <code>encoding</code> <code>Callable</code> <p>Return the encoding of the function in the circuit. For example amplitude or probability of the |0&gt; qubit.</p> <code>grad_encoding</code> <code>Callable</code> <p>Returns the gradient of the chosen encoding.</p> <code>params_layer</code> <code>int</code> <p>Number of parameters per layer.</p> <p>x: NDArray     Values where to evaluate the function encoded in the circuit. encoding : str     Choose between amplitude or probability encoding.     Must be either 'amp' or 'prob'. params_layer : int     Number of parameters per layer.</p> Source code in <code>qubit_approximant/core/circuit/circuit.py</code> <pre><code>def __init__(self, x: NDArray, encoding: str, params_layer: int):\n\"\"\"\n    Parameters\n    ----------\n    x: NDArray\n        Values where to evaluate the function encoded in the circuit.\n    encoding : str\n        Choose between amplitude or probability encoding.\n        Must be either 'amp' or 'prob'.\n    params_layer : int\n        Number of parameters per layer.\n    \"\"\"\n    self.x = x\n\n    if encoding == \"prob\":\n        self.encoding = self.prob_encoding\n        self.grad_encoding = self.grad_prob\n    elif encoding == \"amp\":\n        self.encoding = self.amp_encoding\n        self.grad_encoding = self.grad_amp\n    else:\n        raise ValueError(\"Invalid encoding '{encoding}'. Choose between 'prob' or 'amp'.\")\n\n    self.params_layer = params_layer  # To be defined in subclasses\n</code></pre>"},{"location":"reference/core/circuit/circuit/#qubit_approximant.core.circuit.circuit.Circuit.x","title":"<code>x: NDArray</code>  <code>property</code> <code>writable</code>","text":"<p>Values where to evaluate the function encoded in the circuit.</p> <p>Returns:</p> Type Description <code>NDArray</code> <p>The value of x.</p>"},{"location":"reference/core/circuit/circuit/#qubit_approximant.core.circuit.circuit.Circuit.amp_encoding","title":"<code>amp_encoding(params)</code>","text":"<p>Returns approximate function encoded in the amplitude of the qubit.</p> <p>Parameters:</p> Name Type Description Default <code>params</code> <code>NDArray</code> <p>Parameters of the quantum gates in the layer.</p> required <p>Returns:</p> Type Description <code>NDArray</code> <p>Values of the amplitudes of the |0&gt; qubit for each value of x.</p> Source code in <code>qubit_approximant/core/circuit/circuit.py</code> <pre><code>def amp_encoding(self, params: NDArray) -&gt; NDArray:\n\"\"\"Returns approximate function encoded in the amplitude of the qubit.\n\n    Parameters\n    ----------\n    params : NDArray\n        Parameters of the quantum gates in the layer.\n\n    Returns\n    -------\n    NDArray\n        Values of the amplitudes of the |0&gt; qubit for each value of x.\n    \"\"\"\n    layers = params.size // self.params_layer\n    params = params.reshape(layers, self.params_layer)\n    U = self.layer(params[0, :])[:, :, 0]\n    for i in range(1, params.shape[0]):\n        Ui = self.layer(params[i, :])\n        U = np.einsum(\"gmn, gn -&gt; gm\", Ui, U)\n    return U[:, 0]\n</code></pre>"},{"location":"reference/core/circuit/circuit/#qubit_approximant.core.circuit.circuit.Circuit.grad_amp","title":"<code>grad_amp(params)</code>","text":"<p>Returns the gradient of the amplitude encoding and the encoded function.</p> <p>Parameters:</p> Name Type Description Default <code>params</code> <code>NDArray</code> <p>Parameters of the quantum gates in the layer.</p> required <p>Returns:</p> Type Description <code>tuple[NDArray, NDArray]</code> <p>Gradients of the amplitude with respect to all parameters and the amplitudes for each x.</p> Source code in <code>qubit_approximant/core/circuit/circuit.py</code> <pre><code>def grad_amp(self, params: NDArray) -&gt; tuple[NDArray, NDArray]:\n\"\"\"Returns the gradient of the amplitude encoding and the encoded function.\n\n    Parameters\n    ----------\n    params : NDArray\n        Parameters of the quantum gates in the layer.\n\n    Returns\n    -------\n    tuple[NDArray, NDArray]\n        Gradients of the amplitude with respect to all parameters and the amplitudes for each x.\n    \"\"\"\n    layers = params.size // self.params_layer\n    params = params.reshape(layers, self.params_layer)\n    U = np.tensordot(np.ones(self.x.size), np.array([1, 0]), axes=0)  # dim (G,2)\n    D = np.zeros((layers, self.params_layer, self.x.size, 2), dtype=np.complex128)\n\n    for i in range(layers):\n        DUi = self.grad_layer(params[i, :])  # dim (4,G,2)\n        # j is each of the derivatives\n        D[i, ...] = np.einsum(\"jgmn, gn -&gt; jgm\", DUi, U)\n        # Multiply derivative times next layer\n        Ui = self.layer(params[i, :])\n        U = np.einsum(\"gmn, gn -&gt; gm\", Ui, U)\n\n    grad = np.zeros((layers, self.params_layer, self.x.size), dtype=np.complex128)\n    grad[layers - 1] = D[layers - 1, :, :, 0]\n    # In the first iteration we reuse the L-th layer\n    B = Ui[:, 0, :]\n    for i in range(layers - 2, -1, -1):\n        grad[i, ...] = np.einsum(\"gm, jgm -&gt; jg\", B, D[i, ...])\n        # Multiply derivative times previous layer\n        Ui = self.layer(params[i, :])\n        B = np.einsum(\"gn, gnm -&gt; gm\", B, Ui)\n\n    grad = np.einsum(\"ijg -&gt; gij\", grad)\n    grad = grad.reshape(self.x.size, -1)  # D has shape (x, L*4)\n    fn_approx = U[:, 0]\n\n    return grad, fn_approx\n</code></pre>"},{"location":"reference/core/circuit/circuit/#qubit_approximant.core.circuit.circuit.Circuit.grad_layer","title":"<code>grad_layer(params)</code>  <code>abstractmethod</code>","text":"<p>Returns the derivative of one layer with respect to its parameters.</p> <p>Parameters:</p> Name Type Description Default <code>params</code> <code>NDArray</code> <p>Parameters of the quantum gates in the layer.</p> required <p>Returns:</p> Type Description <code>NDArray</code> <p>Values of the probabilities of the |0&gt; qubit for each value of x.</p> Source code in <code>qubit_approximant/core/circuit/circuit.py</code> <pre><code>@abstractmethod\ndef grad_layer(self, params: NDArray) -&gt; NDArray:\n\"\"\"Returns the derivative of one layer with respect to its parameters.\n\n    Parameters\n    ----------\n    params : NDArray\n        Parameters of the quantum gates in the layer.\n\n    Returns\n    -------\n    NDArray\n        Values of the probabilities of the |0&gt; qubit for each value of x.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/core/circuit/circuit/#qubit_approximant.core.circuit.circuit.Circuit.grad_prob","title":"<code>grad_prob(params)</code>","text":"<p>Returns the gradient of the probability encoding and the probability encoding.</p> <p>Parameters:</p> Name Type Description Default <code>params</code> <code>NDArray</code> <p>Parameters of the quantum gates in the layer.</p> required <p>Returns:</p> Type Description <code>tuple[NDArray, NDArray]</code> <p>Gradients of the probability with respect to all parameters and the probability for each x.</p> Source code in <code>qubit_approximant/core/circuit/circuit.py</code> <pre><code>def grad_prob(self, params: NDArray) -&gt; tuple[NDArray, NDArray]:\n\"\"\"Returns the gradient of the probability encoding and the probability encoding.\n\n    Parameters\n    ----------\n    params : NDArray\n        Parameters of the quantum gates in the layer.\n\n    Returns\n    -------\n    tuple[NDArray, NDArray]\n        Gradients of the probability with respect to all parameters\n        and the probability for each x.\n    \"\"\"\n    grad_amp, amp = self.grad_amp(params)\n    fn_approx = amp.real**2 + amp.imag**2\n    grad_prob = 2 * np.real(np.einsum(\"g, gi -&gt; gi\", amp.conj(), grad_amp))\n    return grad_prob, fn_approx\n</code></pre>"},{"location":"reference/core/circuit/circuit/#qubit_approximant.core.circuit.circuit.Circuit.layer","title":"<code>layer(params)</code>  <code>abstractmethod</code>","text":"<p>Returns the layer of our circuit</p> <p>Parameters:</p> Name Type Description Default <code>params</code> <code>NDArray</code> <p>Parameters of the quantum gates in the layer.</p> required <p>Returns:</p> Type Description <code>NDArray</code> <p>Unitary matrix of the layer with size (x,2,2)</p> Source code in <code>qubit_approximant/core/circuit/circuit.py</code> <pre><code>@abstractmethod\ndef layer(self, params: NDArray) -&gt; NDArray:\n\"\"\"Returns the layer of our circuit\n\n    Parameters\n    ----------\n    params : NDArray\n        Parameters of the quantum gates in the layer.\n\n    Returns\n    -------\n    NDArray\n        Unitary matrix of the layer with size (x,2,2)\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/core/circuit/circuit/#qubit_approximant.core.circuit.circuit.Circuit.prob_encoding","title":"<code>prob_encoding(params)</code>","text":"<p>Returns approximate function encoded in the probability of the qubit. s         Parameters         ----------         params : NDArray             Parameters of the quantum gates in the layer.</p> <pre><code>    Returns\n    -------\n    NDArray\n        Values of the probabilities of the |0&gt; qubit for each value of x.\n</code></pre> Source code in <code>qubit_approximant/core/circuit/circuit.py</code> <pre><code>def prob_encoding(self, params: NDArray) -&gt; NDArray:\n\"\"\"Returns approximate function encoded in the probability of the qubit.\n    s\n            Parameters\n            ----------\n            params : NDArray\n                Parameters of the quantum gates in the layer.\n\n            Returns\n            -------\n            NDArray\n                Values of the probabilities of the |0&gt; qubit for each value of x.\n    \"\"\"\n    fn_amp = self.amp_encoding(params)\n    return fn_amp.real**2 + fn_amp.imag**2\n</code></pre>"},{"location":"reference/core/circuit/circuit/#qubit_approximant.core.circuit.circuit.CircuitRxRy","title":"<code>CircuitRxRy(x, encoding)</code>","text":"<p>         Bases: <code>Circuit</code></p> <p>Each layer of the circuit is made of three rotations dependent on 3 parameters:</p> <p>L = RX(\u03b8x) RY(w * x + \u03b8y)</p> <p>x: NDArray     The values where we wish to approximate a function. encoding: str     Choose between amplitude or probability encoding.     Must be either 'amp' or 'prob'.</p> Source code in <code>qubit_approximant/core/circuit/circuit.py</code> <pre><code>def __init__(self, x: NDArray, encoding: str):\n\"\"\"\n    Parameters\n    ----------\n    x: NDArray\n        The values where we wish to approximate a function.\n    encoding: str\n        Choose between amplitude or probability encoding.\n        Must be either 'amp' or 'prob'.\n    \"\"\"\n    self.params_layer = 3\n    super().__init__(x, encoding, self.params_layer)\n</code></pre>"},{"location":"reference/core/circuit/circuit/#qubit_approximant.core.circuit.circuit.CircuitRxRy.grad_layer","title":"<code>grad_layer(params)</code>","text":"<p>Returns the derivative of one layer with respect to its 3 parameters.</p> <p>Parameters:</p> Name Type Description Default <code>params</code> <code>NDArray</code> <p>Parameters of the quantum gates in the layer.</p> required <p>Returns:</p> Type Description <code>NDArray</code> <p>Gradient of the layer with respect to each parameter.</p> Source code in <code>qubit_approximant/core/circuit/circuit.py</code> <pre><code>def grad_layer(self, params: NDArray) -&gt; NDArray:\n\"\"\"Returns the derivative of one layer with respect to its 3 parameters.\n\n    Parameters\n    ----------\n    params : NDArray\n        Parameters of the quantum gates in the layer.\n\n    Returns\n    -------\n    NDArray\n        Gradient of the layer with respect to each parameter.\n    \"\"\"\n    w = params[0]\n    \u03b8x = params[1]\n    \u03b8y = params[2]\n    Dx = np.einsum(\"mng, np -&gt; gmp\", RY(w * self.x + \u03b8y), grad_RX(\u03b8x))\n    Dy = np.einsum(\"mng, np -&gt; gmp\", grad_RY(w * self.x + \u03b8y), RX(\u03b8x))\n    Dw = np.einsum(\"gmn, g -&gt; gmn\", Dy, self.x)\n    return np.array([Dw, Dx, Dy])  # type: ignore\n</code></pre>"},{"location":"reference/core/circuit/circuit/#qubit_approximant.core.circuit.circuit.CircuitRxRy.layer","title":"<code>layer(params)</code>","text":"<p>Each layer is the product of two rotations. L = RX(\u03b8x) RY(w * x + \u03b8y)</p>"},{"location":"reference/core/circuit/circuit/#qubit_approximant.core.circuit.circuit.CircuitRxRy.layer--parmeters","title":"Parmeters","text":"<p>params : NDArray     Parameters of the gates in the layer.</p> <p>Returns:</p> Type Description <code>NDArray</code> <p>Unitary matrix of the layer with size (x,2,2)</p> <p>Raises:</p> Type Description <code>ParameterError</code> <p>The number of parameters given does not correspond with the circuit ansatz.</p> Source code in <code>qubit_approximant/core/circuit/circuit.py</code> <pre><code>def layer(self, params: NDArray) -&gt; NDArray:\n\"\"\"\n    Each layer is the product of two rotations.\n    L = RX(\u03b8x) RY(w * x + \u03b8y)\n\n    Parmeters\n    ---------\n    params : NDArray\n        Parameters of the gates in the layer.\n\n    Returns\n    -------\n    NDArray\n        Unitary matrix of the layer with size (x,2,2)\n\n    Raises\n    ------\n    ParameterError\n        The number of parameters given does not correspond with\n        the circuit ansatz.\n    \"\"\"\n    if params.size != self.params_layer:\n        raise ParameterError(self.params_layer)\n    w = params[0]\n    \u03b8x = params[1]\n    \u03b8y = params[2]\n    # move the x axis to first position\n    return np.einsum(\"mng, np -&gt; gmp\", RY(w * self.x + \u03b8y), RX(\u03b8x))\n</code></pre>"},{"location":"reference/core/circuit/circuit/#qubit_approximant.core.circuit.circuit.CircuitRxRyRz","title":"<code>CircuitRxRyRz(x, encoding)</code>","text":"<p>         Bases: <code>Circuit</code></p> <p>Each layer of the circuit is made of three rotations dependent on 4 parameters:</p> <p>L = RX(x * w + \u03b8x) RY(\u03b8y) RZ(\u03b8z)</p> <p>x: NDArray     The values where we wish to approximate a function. encoding: str     Choose between amplitude or probability encoding.     Must be either 'amp' or 'prob'.</p> Source code in <code>qubit_approximant/core/circuit/circuit.py</code> <pre><code>def __init__(self, x: NDArray, encoding: str):\n\"\"\"\n    Parameters\n    ----------\n    x: NDArray\n        The values where we wish to approximate a function.\n    encoding: str\n        Choose between amplitude or probability encoding.\n        Must be either 'amp' or 'prob'.\n    \"\"\"\n    self.params_layer = 4\n    super().__init__(x, encoding, self.params_layer)\n</code></pre>"},{"location":"reference/core/circuit/circuit/#qubit_approximant.core.circuit.circuit.CircuitRxRyRz.grad_layer","title":"<code>grad_layer(params)</code>","text":"<p>Returns the derivative of one layer with respect to its 4 parameters.</p> <p>Parameters:</p> Name Type Description Default <code>params</code> <code>NDArray</code> <p>Parameters of the quantum gates in the layer.</p> required <p>Returns:</p> Type Description <code>NDArray</code> <p>Gradient of the layer with respect to each parameter.</p> Source code in <code>qubit_approximant/core/circuit/circuit.py</code> <pre><code>def grad_layer(self, params: NDArray) -&gt; NDArray:\n\"\"\"Returns the derivative of one layer with respect to its 4 parameters.\n\n    Parameters\n    ----------\n    params : NDArray\n        Parameters of the quantum gates in the layer.\n\n    Returns\n    -------\n    NDArray\n        Gradient of the layer with respect to each parameter.\n    \"\"\"\n    w = params[0]\n    \u03b8x = params[1]\n    \u03b8y = params[2]\n    \u03b8z = params[3]\n\n    Dx = np.einsum(\"mn, np, pqg -&gt; gmq\", RZ(\u03b8z), RY(\u03b8y), grad_RX(w * self.x + \u03b8x))\n    Dw = np.einsum(\"gmq, g -&gt; gmq\", Dx, self.x)\n    Dy = np.einsum(\"mn, np, pqg -&gt; gmq\", RZ(\u03b8z), grad_RY(\u03b8y), RX(w * self.x + \u03b8x))\n    Dz = np.einsum(\"mn, np, pqg -&gt; gmq\", grad_RZ(\u03b8z), RY(\u03b8y), RX(w * self.x + \u03b8x))\n\n    return np.array([Dw, Dx, Dy, Dz])  # type: ignore\n</code></pre>"},{"location":"reference/core/circuit/circuit/#qubit_approximant.core.circuit.circuit.CircuitRxRyRz.layer","title":"<code>layer(params)</code>","text":"<p>Returns the layer of the circuit: L = RX(x * w + \u03b80) RY(\u03b81) RZ(\u03b82)</p> <p>Parameters:</p> Name Type Description Default <code>params</code> <code>NDArray</code> <p>Parameters of the quantum gates in the layer.</p> required <p>Returns:</p> Type Description <code>NDArray</code> <p>Unitary matrix of the layer with size (x,2,2)</p> <p>Raises:</p> Type Description <code>ParameterError</code> <p>The number of parameters given does not correspond with the circuit ansatz.</p> Source code in <code>qubit_approximant/core/circuit/circuit.py</code> <pre><code>def layer(self, params: NDArray) -&gt; NDArray:\n\"\"\"\n    Returns the layer of the circuit:\n    L = RX(x * w + \u03b80) RY(\u03b81) RZ(\u03b82)\n\n    Parameters\n    ----------\n    params : NDArray\n        Parameters of the quantum gates in the layer.\n\n    Returns\n    -------\n    NDArray\n        Unitary matrix of the layer with size (x,2,2)\n\n    Raises\n    ------\n    ParameterError\n        The number of parameters given does not correspond with\n        the circuit ansatz.\n    \"\"\"\n    if params.size != self.params_layer:\n        raise ParameterError(self.params_layer)\n    w = params[0]\n    \u03b8x = params[1]\n    \u03b8y = params[2]\n    \u03b8z = params[3]\n    # move the x axis to first position\n    return np.einsum(\"mn, np, pqg -&gt; gmq\", RZ(\u03b8z), RY(\u03b8y), RX(w * self.x + \u03b8x))\n</code></pre>"},{"location":"reference/core/circuit/circuit/#qubit_approximant.core.circuit.circuit.CircuitRy","title":"<code>CircuitRy(x, encoding)</code>","text":"<p>         Bases: <code>Circuit</code></p> <p>Each layer of the circuit is made of three rotations dependent on 2 parameters:</p> <p>L = RY(w * x + \u03b8y)</p> <p>x: NDArray     The values where we wish to approximate a function. encoding: str     Choose between amplitude or probability encoding.     Must be either 'amp' or 'prob'.</p> Source code in <code>qubit_approximant/core/circuit/circuit.py</code> <pre><code>def __init__(self, x: NDArray, encoding: str):\n\"\"\"\n    Parameters\n    ----------\n    x: NDArray\n        The values where we wish to approximate a function.\n    encoding: str\n        Choose between amplitude or probability encoding.\n        Must be either 'amp' or 'prob'.\n    \"\"\"\n    self.params_layer = 2\n    super().__init__(x, encoding, self.params_layer)\n</code></pre>"},{"location":"reference/core/circuit/circuit/#qubit_approximant.core.circuit.circuit.CircuitRy.grad_layer","title":"<code>grad_layer(params)</code>","text":"<p>Returns the derivative of one layer with respect to its 2 parameters.</p> <p>Parameters:</p> Name Type Description Default <code>params</code> <code>NDArray</code> <p>Parameters of the quantum gates in the layer.</p> required <p>Returns:</p> Type Description <code>NDArray</code> <p>Gradient of the layer with respect to each parameter.</p> Source code in <code>qubit_approximant/core/circuit/circuit.py</code> <pre><code>def grad_layer(self, params: NDArray) -&gt; NDArray:\n\"\"\"Returns the derivative of one layer with respect to its 2 parameters.\n\n    Parameters\n    ----------\n    params : NDArray\n        Parameters of the quantum gates in the layer.\n\n    Returns\n    -------\n    NDArray\n        Gradient of the layer with respect to each parameter.\n    \"\"\"\n    w = params[0]\n    \u03b8y = params[1]\n    Dy = np.einsum(\"mng -&gt; gmn\", grad_RY(w * self.x + \u03b8y))\n    Dw = np.einsum(\"gmn, g -&gt; gmn\", Dy, self.x)\n\n    return np.array([Dw, Dy])  # type: ignore\n</code></pre>"},{"location":"reference/core/circuit/circuit/#qubit_approximant.core.circuit.circuit.CircuitRy.layer","title":"<code>layer(params)</code>","text":"<p>Each layer is one RY rotation: L = RY(w * x + \u03b8y)</p>"},{"location":"reference/core/circuit/circuit/#qubit_approximant.core.circuit.circuit.CircuitRy.layer--parmeters","title":"Parmeters","text":"<p>params : NDArray     Parameters of the gates in the layer.</p> <p>Returns:</p> Type Description <code>NDArray</code> <p>Unitary matrix of the layer with size (x,2,2)</p> <p>Raises:</p> Type Description <code>ParameterError</code> <p>The number of parameters given does not correspond with the circuit ansatz.</p> Source code in <code>qubit_approximant/core/circuit/circuit.py</code> <pre><code>def layer(self, params: NDArray) -&gt; NDArray:\n\"\"\"\n    Each layer is one RY rotation:\n    L = RY(w * x + \u03b8y)\n\n    Parmeters\n    ---------\n    params : NDArray\n        Parameters of the gates in the layer.\n\n    Returns\n    -------\n    NDArray\n        Unitary matrix of the layer with size (x,2,2)\n\n    Raises\n    ------\n    ParameterError\n        The number of parameters given does not correspond with\n        the circuit ansatz.\n    \"\"\"\n    if params.size != self.params_layer:\n        raise ParameterError(self.params_layer)\n    w = params[0]\n    \u03b8y = params[1]\n    # move the x axis to first position\n    return np.einsum(\"mng -&gt; gmn\", RY(w * self.x + \u03b8y))\n</code></pre>"},{"location":"reference/core/circuit/circuit/#qubit_approximant.core.circuit.circuit.ParameterError","title":"<code>ParameterError(params_per_layer)</code>","text":"<p>         Bases: <code>Exception</code></p> <p>Exception raised when the number of parameters given does not correspond with the circuit ansatz.</p> Source code in <code>qubit_approximant/core/circuit/circuit.py</code> <pre><code>def __init__(self, params_per_layer):\n    self.message = f\"The number of parameters must be {params_per_layer} per layer.\"\n    super().__init__(self.message)\n</code></pre>"},{"location":"reference/core/cost/","title":"cost","text":""},{"location":"reference/core/cost/#qubit_approximant.core.cost","title":"<code>qubit_approximant.core.cost</code>","text":""},{"location":"reference/core/cost/_cost_metrics/","title":"_cost_metrics","text":""},{"location":"reference/core/cost/_cost_metrics/#qubit_approximant.core.cost._cost_metrics","title":"<code>qubit_approximant.core.cost._cost_metrics</code>","text":"<p>Metrics and their gradients to use in the cost function and optimization process.</p>"},{"location":"reference/core/cost/_cost_metrics/#qubit_approximant.core.cost._cost_metrics.grad_kl_divergence","title":"<code>grad_kl_divergence(fn, fn_approx, grad_fn_approx)</code>","text":"<p>Returns the gradient of the KL divergence.</p> Source code in <code>qubit_approximant/core/cost/_cost_metrics.py</code> <pre><code>def grad_kl_divergence(fn: NDArray, fn_approx: NDArray, grad_fn_approx: NDArray) -&gt; NDArray:\n\"\"\"Returns the gradient of the KL divergence.\"\"\"\n    return np.real(np.einsum(\"g, gi -&gt; i\", fn / fn_approx, grad_fn_approx)) / fn.size\n</code></pre>"},{"location":"reference/core/cost/_cost_metrics/#qubit_approximant.core.cost._cost_metrics.grad_log_cosh","title":"<code>grad_log_cosh(fn, fn_approx, grad_fn_approx)</code>","text":"<p>Returns the gradiend of the logarithm of the hyperbolic cosine.</p> Source code in <code>qubit_approximant/core/cost/_cost_metrics.py</code> <pre><code>def grad_log_cosh(fn: NDArray, fn_approx: NDArray, grad_fn_approx: NDArray) -&gt; NDArray:\n\"\"\"Returns the gradiend of the logarithm of the hyperbolic cosine.\"\"\"\n    fn_diff = fn_approx - fn\n    return np.real(np.einsum(\"g, gi -&gt; i\", np.tanh(fn_diff), grad_fn_approx)) / fn.size\n</code></pre>"},{"location":"reference/core/cost/_cost_metrics/#qubit_approximant.core.cost._cost_metrics.grad_mse","title":"<code>grad_mse(fn, fn_approx, grad_fn_approx)</code>","text":"<p>Returns the gradient of the minimum square error.</p> Source code in <code>qubit_approximant/core/cost/_cost_metrics.py</code> <pre><code>def grad_mse(fn: NDArray, fn_approx: NDArray, grad_fn_approx: NDArray) -&gt; NDArray:\n\"\"\"Returns the gradient of the minimum square error.\"\"\"\n    fn_diff = fn_approx - fn\n    return 2 * np.real(np.einsum(\"g, gi -&gt; i\", fn_diff.conj(), grad_fn_approx)) / fn.size\n</code></pre>"},{"location":"reference/core/cost/_cost_metrics/#qubit_approximant.core.cost._cost_metrics.grad_mse_weighted","title":"<code>grad_mse_weighted(fn, fn_approx, grad_fn_approx)</code>","text":"<p>Returns the gradient of the weighted minimum square error.</p> Source code in <code>qubit_approximant/core/cost/_cost_metrics.py</code> <pre><code>def grad_mse_weighted(fn: NDArray, fn_approx: NDArray, grad_fn_approx: NDArray) -&gt; NDArray:\n\"\"\"Returns the gradient of the weighted minimum square error.\"\"\"\n    fn_diff = fn_approx - fn\n    return (\n        2 * np.real(np.einsum(\"g, g, gi -&gt; i\", fn, fn_diff.conj(), grad_fn_approx)) / fn.size\n    )  # fn is real!!\n</code></pre>"},{"location":"reference/core/cost/_cost_metrics/#qubit_approximant.core.cost._cost_metrics.grad_rmse","title":"<code>grad_rmse(fn, fn_approx, grad_fn_approx)</code>","text":"<p>Returns the gradient of the root minimum square error.</p> Source code in <code>qubit_approximant/core/cost/_cost_metrics.py</code> <pre><code>def grad_rmse(fn: NDArray, fn_approx: NDArray, grad_fn_approx: NDArray) -&gt; NDArray:\n\"\"\"Returns the gradient of the root minimum square error.\"\"\"\n    fn_diff = fn_approx - fn\n    coef = 1 / (np.sqrt(fn.size) * np.sqrt(np.sum(np.abs(fn_diff) ** 2) + 1e-9))\n    return coef * np.real(np.einsum(\"g, gi -&gt; i\", fn_diff.conj(), grad_fn_approx))\n</code></pre>"},{"location":"reference/core/cost/_cost_metrics/#qubit_approximant.core.cost._cost_metrics.kl_divergence","title":"<code>kl_divergence(fn, fn_approx)</code>","text":"<p>Returns the KL divergence. This metric should be used with strictly real positive functions</p> Source code in <code>qubit_approximant/core/cost/_cost_metrics.py</code> <pre><code>def kl_divergence(fn: NDArray, fn_approx: NDArray) -&gt; float:\n\"\"\"Returns the KL divergence. This metric should be used\n    with strictly real positive functions\"\"\"\n    return np.mean(fn * np.log(fn_approx / fn))\n</code></pre>"},{"location":"reference/core/cost/_cost_metrics/#qubit_approximant.core.cost._cost_metrics.log_cosh","title":"<code>log_cosh(fn, fn_approx)</code>","text":"<p>Returns the logarithm of the hyperbolic cosine. This metric should be used with strictly real positive functions</p> Source code in <code>qubit_approximant/core/cost/_cost_metrics.py</code> <pre><code>def log_cosh(fn: NDArray, fn_approx: NDArray) -&gt; float:\n\"\"\"Returns the logarithm of the hyperbolic cosine. This metric\n    should be used with strictly real positive functions\"\"\"\n    fn_diff = fn_approx - fn\n    return np.mean(np.log(np.cosh(fn_diff)))\n</code></pre>"},{"location":"reference/core/cost/_cost_metrics/#qubit_approximant.core.cost._cost_metrics.mse","title":"<code>mse(fn, fn_approx)</code>","text":"<p>Returns the minimum square error.</p> Source code in <code>qubit_approximant/core/cost/_cost_metrics.py</code> <pre><code>def mse(fn: NDArray, fn_approx: NDArray) -&gt; float:\n\"\"\"Returns the minimum square error.\"\"\"\n    fn_diff = fn_approx - fn\n    return np.mean(np.absolute(fn_diff) ** 2)\n</code></pre>"},{"location":"reference/core/cost/_cost_metrics/#qubit_approximant.core.cost._cost_metrics.mse_weighted","title":"<code>mse_weighted(fn, fn_approx)</code>","text":"<p>Returns a weighted minimum square error.</p> Source code in <code>qubit_approximant/core/cost/_cost_metrics.py</code> <pre><code>def mse_weighted(fn: NDArray, fn_approx: NDArray) -&gt; float:\n\"\"\"Returns a weighted minimum square error.\"\"\"\n    fn_diff = fn_approx - fn\n    return np.mean(fn * np.absolute(fn_diff) ** 2)\n</code></pre>"},{"location":"reference/core/cost/_cost_metrics/#qubit_approximant.core.cost._cost_metrics.rmse","title":"<code>rmse(fn, fn_approx)</code>","text":"<p>Returns the root minimum square error.</p> Source code in <code>qubit_approximant/core/cost/_cost_metrics.py</code> <pre><code>def rmse(fn: NDArray, fn_approx: NDArray) -&gt; float:\n\"\"\"Returns the root minimum square error.\"\"\"\n    return np.sqrt(mse(fn, fn_approx))\n</code></pre>"},{"location":"reference/core/cost/cost/","title":"cost","text":""},{"location":"reference/core/cost/cost/#qubit_approximant.core.cost.cost","title":"<code>qubit_approximant.core.cost.cost</code>","text":"<p>Cost function to use in our optimizer.</p>"},{"location":"reference/core/cost/cost/#qubit_approximant.core.cost.cost.Cost","title":"<code>Cost(fn, circuit, metric)</code>","text":"<p>Create a cost function from the encoding and the metric.</p> <p>Attributes:</p> Name Type Description <code>metric</code> <code>Callable</code> <p>The metric or loss function to quantify how well our circuit approximates the target function.</p> <code>grad_metric</code> <code>Callable</code> <p>The gradient of the metric or loss function.</p> <code>circuit</code> <code>Circuit</code> <p>Quantum circuit that encodes our function.</p> <code>fn</code> <code>NDArray</code> <p>Function we desire to approximate.</p> <p>fn : NDArray     Function we desire to approximate. circuit : Circuit     Quantum circuit that encodes our function. metric : str     Name of the metric we want to use.     Allowed values are:         - 'mse' (mean square error)         - 'rmse' (root mean square error)         - 'mse_weighted' (mse weighted by fn)         - 'kl_divergence'         - 'log_cosh'.</p> Source code in <code>qubit_approximant/core/cost/cost.py</code> <pre><code>def __init__(self, fn: NDArray, circuit: Circuit, metric: str) -&gt; None:\n\"\"\"\n    Parameters\n    ----------\n    fn : NDArray\n        Function we desire to approximate.\n    circuit : Circuit\n        Quantum circuit that encodes our function.\n    metric : str\n        Name of the metric we want to use.\n        Allowed values are:\n            - 'mse' (mean square error)\n            - 'rmse' (root mean square error)\n            - 'mse_weighted' (mse weighted by fn)\n            - 'kl_divergence'\n            - 'log_cosh'.\n    \"\"\"\n    try:\n        self.metric = globals()[metric]\n        self.grad_metric = globals()[\"grad_\" + metric]\n    except KeyError as e:\n        raise ValueError(\"Invalid metric '{metric}'. Choose between 'MSE' or 'RMSE'.\") from e\n\n    self.circuit = circuit\n    self.fn = fn\n</code></pre>"},{"location":"reference/core/cost/cost/#qubit_approximant.core.cost.cost.Cost.__call__","title":"<code>__call__(params)</code>","text":"<p>Evaluate the cost function given the parameters of the circuit.</p> <p>Parameters:</p> Name Type Description Default <code>params</code> <code>NDArray</code> <p>Parameters of the quantum gates in the layer.</p> required <p>Returns:</p> Type Description <code>float</code> <p>The value of the cost function for the chosen circuit and metric.</p> Source code in <code>qubit_approximant/core/cost/cost.py</code> <pre><code>def __call__(self, params: NDArray) -&gt; float:\n\"\"\"Evaluate the cost function given the parameters of the circuit.\n\n    Parameters\n    ----------\n    params : NDArray\n        Parameters of the quantum gates in the layer.\n\n    Returns\n    -------\n    float\n        The value of the cost function for the chosen circuit and metric.\n    \"\"\"\n    fn_approx = self.circuit.encoding(params)\n    return self.metric(self.fn, fn_approx)\n</code></pre>"},{"location":"reference/core/cost/cost/#qubit_approximant.core.cost.cost.Cost.grad","title":"<code>grad(params)</code>","text":"<p>Return the gradient of the cost function.</p> <p>Parameters:</p> Name Type Description Default <code>params</code> <code>NDArray</code> <p>Parameters of the quantum gates in the layer.</p> required <p>Returns:</p> Type Description <code>NDArray</code> <p>Gradient of the cost.</p> Source code in <code>qubit_approximant/core/cost/cost.py</code> <pre><code>def grad(self, params: NDArray) -&gt; NDArray:\n\"\"\"Return the gradient of the cost function.\n\n    Parameters\n    ----------\n    params : NDArray\n        Parameters of the quantum gates in the layer.\n\n    Returns\n    -------\n    NDArray\n        Gradient of the cost.\n    \"\"\"\n    grad_fn_approx, fn_approx = self.circuit.grad_encoding(params)\n    return self.grad_metric(self.fn, fn_approx, grad_fn_approx)\n</code></pre>"},{"location":"reference/core/optimizer/","title":"optimizer","text":""},{"location":"reference/core/optimizer/#qubit_approximant.core.optimizer","title":"<code>qubit_approximant.core.optimizer</code>","text":""},{"location":"reference/core/optimizer/multilayer_optimizer/","title":"multilayer_optimizer","text":""},{"location":"reference/core/optimizer/multilayer_optimizer/#qubit_approximant.core.optimizer.multilayer_optimizer","title":"<code>qubit_approximant.core.optimizer.multilayer_optimizer</code>","text":"<p>Incremental optimizer</p>"},{"location":"reference/core/optimizer/multilayer_optimizer/#qubit_approximant.core.optimizer.multilayer_optimizer--classes","title":"Classes","text":"<p>MultilayerOptimizer:     Base class for the optimization of circuits with multiple layers. NonIncrementalOptimizer:     This optimizer uses the parameters of an optimized L layer circuit     as input for the optimization of a L+1 layer circuit. IncrementalOptimizer:     This optimizer uses the parameters of an optimized L layer circuit     as input for the optimization of a L+1 layer circuit.</p>"},{"location":"reference/core/optimizer/multilayer_optimizer/#qubit_approximant.core.optimizer.multilayer_optimizer.IncrementalOptimizer","title":"<code>IncrementalOptimizer(min_layer, max_layer, optimizer, new_layer_coef, new_layer_position)</code>","text":"<p>         Bases: <code>MultilayerOptimizer</code></p> <p>This optimizer uses the parameters of an optimized L layer circuit as input for the optimization of a L+1 layer circuit.</p> <p>Attributes:</p> Name Type Description <code>new_layer_position</code> <code>str</code> <p>The position where to add the parameters of the new layer. For, example, it may be the initial or final layer of our circuit.</p> <p>Parameters:</p> Name Type Description Default <code>min_layer</code> <code>int</code> <p>Starting number of layers to optimize.</p> required <code>max_layer</code> <code>int</code> <p>Final number of layers to optimize.</p> required <code>optimizer</code> <code>Optimizer</code> <p>The optimizer used to find the optimum parameters.</p> required <code>new_layer_coef</code> <code>float</code> <p>The coefficient that multiplies the normal distribution of the new parameters in the additional layer.</p> required <code>new_layer_position</code> <code>str</code> <p>The position where to add the parameters of the new layer. For, example, it may be the initial or final layer of our circuit.</p> required Source code in <code>qubit_approximant/core/optimizer/multilayer_optimizer.py</code> <pre><code>def __init__(\n    self,\n    min_layer,\n    max_layer,\n    optimizer: Optimizer,\n    new_layer_coef: float,\n    new_layer_position: str,\n) -&gt; None:\n\"\"\"\n    Initialize a black box optimizer.\n\n    Parameters\n    ----------\n    min_layer : int\n        Starting number of layers to optimize.\n    max_layer : int\n        Final number of layers to optimize.\n    optimizer : Optimizer\n        The optimizer used to find the optimum parameters.\n    new_layer_coef : float\n        The coefficient that multiplies the normal distribution of the\n        new parameters in the additional layer.\n    new_layer_position : str\n        The position where to add the parameters of the new layer. For,\n        example, it may be the initial or final layer of our circuit.\n    \"\"\"\n    if new_layer_position in IncrementalOptimizer.layer_positions:\n        self.new_layer_position = new_layer_position\n    else:\n        raise ValueError(\n            f\"new_layer_position = {new_layer_position} is not supported. \"\n            \"Try 'initial', 'middle', 'final' or 'random'\"\n        )\n    super().__init__(min_layer, max_layer, optimizer, new_layer_coef)\n</code></pre>"},{"location":"reference/core/optimizer/multilayer_optimizer/#qubit_approximant.core.optimizer.multilayer_optimizer.IncrementalOptimizer.inital_params_diff","title":"<code>inital_params_diff: tuple[list[float], list[float]]</code>  <code>property</code>","text":"<p>Returns a list with the mean and standard deviation of the difference between the optimum parameters in the i-th layer and the optimum parameters of the (i+1)-th layer. (We exclude the additional parameters added with the new layer).</p> <p>Returns:</p> Type Description <code>tuple[list[float], list[float]]</code> <p>Mean and standard deviation of the parameter differences.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>Parameter difference only supported for new initial and final layers.</p>"},{"location":"reference/core/optimizer/multilayer_optimizer/#qubit_approximant.core.optimizer.multilayer_optimizer.IncrementalOptimizer.__call__","title":"<code>__call__(cost, grad_cost, init_params)</code>","text":"<p>Calculate the optimized parameters for each number of layers.</p> <p>Parameters:</p> Name Type Description Default <code>cost</code> <code>Callable</code> <p>Cost function to be minimized.</p> required <code>grad_cost</code> <code>Callable</code> <p>Gradient of the cost function.</p> required <code>init_params</code> <code>NDArray</code> <p>Initial parameter guess for the cost function; used to initialize the optimizer.</p> required <p>Returns:</p> Type Description <code>list[NDArray]</code> <p>The optimum parameters for each number of layers.</p> Source code in <code>qubit_approximant/core/optimizer/multilayer_optimizer.py</code> <pre><code>def __call__(self, cost: Callable, grad_cost: Callable, init_params: NDArray) -&gt; list[NDArray]:\n\"\"\"Calculate the optimized parameters for each number of layers.\n\n    Parameters\n    ----------\n    cost : Callable\n        Cost function to be minimized.\n    grad_cost : Callable\n        Gradient of the cost function.\n    init_params : NDArray\n        Initial parameter guess for the cost function; used to initialize the optimizer.\n\n    Returns\n    -------\n    list[NDArray]\n        The optimum parameters for each number of layers.\n    \"\"\"\n    self.params_layer = init_params.size // self.min_layer\n    params = init_params\n    self.params_list = []\n\n    for layer in range(self.min_layer, self.max_layer + 1):\n        params = self.optimizer(cost, grad_cost, params)\n        self.params_list.append(params)\n        params = self._new_initial_params(params, layer)\n    return self.params_list\n</code></pre>"},{"location":"reference/core/optimizer/multilayer_optimizer/#qubit_approximant.core.optimizer.multilayer_optimizer.MultilayerOptimizer","title":"<code>MultilayerOptimizer(min_layer, max_layer, optimizer, new_layer_coef=0.3)</code>","text":"<p>         Bases: <code>ABC</code></p> <p>This optimizer uses the parameters of an optimized L layer circuit as input for the optimization of a L+1 layer circuit.</p> <p>Attributes:</p> Name Type Description <code>min_layer</code> <code>int</code> <p>Starting number of layers to optimize.</p> <code>max_layer</code> <code>int</code> <p>Final number of layers to optimize.</p> <code>optimizer</code> <code>Optimizer</code> <p>The optimizer used to find the optimum parameters.</p> <code>new_layer_coef</code> <code>float</code> <p>The coefficient that multiplies the normal distribution of the new parameters in the additional layer.</p> <p>Parameters:</p> Name Type Description Default <code>min_layer</code> <code>int</code> <p>Starting number of layers to optimize.</p> required <code>max_layer</code> <code>int</code> <p>Final number of layers to optimize.</p> required <code>optimizer</code> <code>Optimizer</code> <p>The optimizer used to find the optimum parameters.</p> required <code>new_layer_coef</code> <code>float</code> <p>The coefficient that multiplies the normal distribution of the new parameters in the additional layer.</p> <code>0.3</code> Source code in <code>qubit_approximant/core/optimizer/multilayer_optimizer.py</code> <pre><code>def __init__(self, min_layer, max_layer, optimizer: Optimizer, new_layer_coef: float = 0.3):\n\"\"\"\n    Initialize a black box optimizer.\n\n    Parameters\n    ----------\n    min_layer : int\n        Starting number of layers to optimize.\n    max_layer : int\n        Final number of layers to optimize.\n    optimizer : Optimizer\n        The optimizer used to find the optimum parameters.\n    new_layer_coef : float\n        The coefficient that multiplies the normal distribution of the\n        new parameters in the additional layer.\n    \"\"\"\n    self.min_layer = min_layer\n    self.max_layer = max_layer\n    self.optimizer = optimizer\n    self.new_layer_coef = new_layer_coef\n</code></pre>"},{"location":"reference/core/optimizer/multilayer_optimizer/#qubit_approximant.core.optimizer.multilayer_optimizer.MultilayerOptimizer.__call__","title":"<code>__call__(cost, grad_cost, init_params)</code>  <code>abstractmethod</code>","text":"<p>Calculate the optimized parameters for each number of layers.</p> <p>Parameters:</p> Name Type Description Default <code>cost</code> <code>Callable</code> <p>Cost function to be minimized.</p> required <code>grad_cost</code> <code>Callable</code> <p>Gradient of the cost function.</p> required <code>init_params</code> <code>NDArray</code> <p>Initial parameter guess for the cost function; used to initialize the optimizer.</p> required <p>Returns:</p> Type Description <code>list of NDArray</code> <p>The optimum parameters for each number of layers.</p> Source code in <code>qubit_approximant/core/optimizer/multilayer_optimizer.py</code> <pre><code>@abstractmethod\ndef __call__(self, cost: Callable, grad_cost: Callable, init_params: NDArray) -&gt; list[NDArray]:\n\"\"\"\n    Calculate the optimized parameters for each number of layers.\n\n    Parameters\n    ----------\n    cost: Callable\n        Cost function to be minimized.\n    grad_cost: Callable\n        Gradient of the cost function.\n    init_params : NDArray\n        Initial parameter guess for the cost function; used to initialize the optimizer.\n\n    Returns\n    -------\n    list of NDArray\n        The optimum parameters for each number of layers.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/core/optimizer/multilayer_optimizer/#qubit_approximant.core.optimizer.multilayer_optimizer.NonIncrementalOptimizer","title":"<code>NonIncrementalOptimizer(min_layer, max_layer, optimizer, new_layer_coef)</code>","text":"<p>         Bases: <code>MultilayerOptimizer</code></p> <p>This optimizer creates new initial parameters for the optimization of a circuit with an additional layer.</p> <p>Parameters:</p> Name Type Description Default <code>min_layer</code> <code>int</code> <p>Starting number of layers to optimize.</p> required <code>max_layer</code> <code>int</code> <p>Final number of layers to optimize.</p> required <code>optimizer</code> <code>Optimizer</code> <p>The optimizer used to find the optimum parameters.</p> required <code>new_layer_coef</code> <code>float</code> <p>The coefficient that multiplies the normal distribution of the new parameters in the additional layer.</p> required Source code in <code>qubit_approximant/core/optimizer/multilayer_optimizer.py</code> <pre><code>def __init__(self, min_layer, max_layer, optimizer: Optimizer, new_layer_coef: float):\n\"\"\"\n    Initialize a black box optimizer.\n\n    Parameters\n    ----------\n    min_layer : int\n        Starting number of layers to optimize.\n    max_layer : int\n        Final number of layers to optimize.\n    optimizer : Optimizer\n        The optimizer used to find the optimum parameters.\n    new_layer_coef : float\n        The coefficient that multiplies the normal distribution of the\n        new parameters in the additional layer.\n    \"\"\"\n    super().__init__(min_layer, max_layer, optimizer, new_layer_coef)\n</code></pre>"},{"location":"reference/core/optimizer/multilayer_optimizer/#qubit_approximant.core.optimizer.multilayer_optimizer.NonIncrementalOptimizer.__call__","title":"<code>__call__(cost, grad_cost, init_params)</code>","text":"<p>Calculate the optimized parameters for each number of layers.</p> <p>Parameters:</p> Name Type Description Default <code>cost</code> <code>Callable</code> <p>Cost function to be minimized.</p> required <code>grad_cost</code> <code>Callable</code> <p>Gradient of the cost function.</p> required <code>init_params</code> <code>NDArray</code> <p>Initial parameter guess for the cost function; used to initialize the optimizer.</p> required <p>Returns:</p> Type Description <code>list[NDArray]</code> <p>The optimum parameters for each number of layers.</p> Source code in <code>qubit_approximant/core/optimizer/multilayer_optimizer.py</code> <pre><code>def __call__(self, cost: Callable, grad_cost: Callable, init_params: NDArray) -&gt; list[NDArray]:\n\"\"\"\n    Calculate the optimized parameters for each number of layers.\n\n    Parameters\n    ----------\n    cost: Callable\n        Cost function to be minimized.\n    grad_cost: Callable\n        Gradient of the cost function.\n    init_params : NDArray\n        Initial parameter guess for the cost function; used to initialize the optimizer.\n\n    Returns\n    -------\n    list[NDArray]\n        The optimum parameters for each number of layers.\n    \"\"\"\n    self.params_layer = init_params.size // self.min_layer\n    self.params_list = []\n    params = init_params\n    rng = np.random.default_rng()\n\n    for layer in range(self.min_layer, self.max_layer + 1):\n        params = self.optimizer(cost, grad_cost, params)\n        self.params_list.append(params)\n        params = self.new_layer_coef * rng.standard_normal((layer + 1) * self.params_layer)\n    return self.params_list\n</code></pre>"},{"location":"reference/core/optimizer/optimizer/","title":"optimizer","text":""},{"location":"reference/core/optimizer/optimizer/#qubit_approximant.core.optimizer.optimizer","title":"<code>qubit_approximant.core.optimizer.optimizer</code>","text":"<p>Optimizers for our cost function.</p>"},{"location":"reference/core/optimizer/optimizer/#qubit_approximant.core.optimizer.optimizer--classes","title":"Classes","text":"<p>Optimizer:     Base class for the optimization of a circuit with fixed number of layers. BlackBoxOptimizer:     This optimizer uses scipy.minimize as a black box optimizer. GDOptimizer:     Gradient descent optimizer. AdamOptimizer:     A Method for Stochastic Optimization optimizer.</p>"},{"location":"reference/core/optimizer/optimizer/#qubit_approximant.core.optimizer.optimizer.AdamOptimizer","title":"<code>AdamOptimizer(iters, step_size=0.01, beta1=0.9, beta2=0.999, eps=1e-08)</code>","text":"<p>         Bases: <code>GDOptimizer</code></p> <p>Adam (A Method for Stochastic Optimization) optimizer.</p> <p>Attributes:</p> Name Type Description <code>step_size</code> <code>float</code> <p>The size of the step of each gradient descent iteration.</p> <code>beta1</code> <code>float</code> <p>The factor for the average gradient.</p> <code>beta2</code> <code>float</code> <p>The factor for the average squared gradient.</p> <code>eps</code> <code>float</code> <p>A regularizing small parameter used to avoid division by zero.</p>"},{"location":"reference/core/optimizer/optimizer/#qubit_approximant.core.optimizer.optimizer.AdamOptimizer--references","title":"References","text":"<p>The optimizer is described in [1]_.</p> <p>.. [1] https://arxiv.org/abs/1412.6980</p> <p>iters : int     The number of gradient descent iterations to perform. step_size : float     The size of the step of each gradient descent iteration. beta1 : float     The factor for the average gradient. beta2 : float     The factor for the average squared gradient. eps: float     A regularizing small parameter used to avoid division by zero.</p> Source code in <code>qubit_approximant/core/optimizer/optimizer.py</code> <pre><code>def __init__(\n    self,\n    iters: int,\n    step_size: float = 0.01,\n    beta1: float = 0.9,\n    beta2: float = 0.999,\n    eps: float = 1e-8,\n):\n\"\"\"\n    Parameters\n    ----------\n    iters : int\n        The number of gradient descent iterations to perform.\n    step_size : float\n        The size of the step of each gradient descent iteration.\n    beta1 : float\n        The factor for the average gradient.\n    beta2 : float\n        The factor for the average squared gradient.\n    eps: float\n        A regularizing small parameter used to avoid division by zero.\n    \"\"\"\n    self.step_size = step_size\n    self.beta1 = beta1\n    self.beta2 = beta2\n    self.eps = eps\n    super().__init__(iters, step_size)\n</code></pre>"},{"location":"reference/core/optimizer/optimizer/#qubit_approximant.core.optimizer.optimizer.AdamOptimizer.step","title":"<code>step(grad_cost, params)</code>","text":"<p>Update the parameters with a step of Adam. Adam changes the step size in each iteration.</p> Source code in <code>qubit_approximant/core/optimizer/optimizer.py</code> <pre><code>def step(self, grad_cost: Callable, params: NDArray) -&gt; NDArray:\n\"\"\"Update the parameters with a step of Adam. Adam changes the step\n    size in each iteration.\"\"\"\n    m = zeros_like(params)\n    v = zeros_like(params)\n    grad = grad_cost(params)\n\n    m = self.beta1 * m + (1.0 - self.beta1) * grad\n    v = self.beta2 * v + (1.0 - self.beta2) * grad**2\n    mhat = m / (1.0 - self.beta1 ** (self.iter_index + 1))\n    vhat = v / (1.0 - self.beta2 ** (self.iter_index + 1))\n    params = params - self.step_size * mhat / (sqrt(vhat) + self.eps)\n\n    return params\n</code></pre>"},{"location":"reference/core/optimizer/optimizer/#qubit_approximant.core.optimizer.optimizer.BlackBoxOptimizer","title":"<code>BlackBoxOptimizer(method, method_kwargs=None)</code>","text":"<p>         Bases: <code>Optimizer</code></p> <p>Optimizer that uses scipy's inbuilt function <code>minimize</code>.</p> <p>Attributes:</p> Name Type Description <code>method</code> <code>str</code> <p>The desired optimization method.</p> <code>method_kwargs</code> <code>dict</code> <p>A dictionary with keyword arguments for the optimizer.</p> <p>Parameters:</p> Name Type Description Default <code>method</code> <code>str</code> <p>The desired optimization method.</p> required <code>method_kwargs</code> <code>dict</code> <p>A dictionary with keyword arguments for the optimizer.</p> <code>None</code> Source code in <code>qubit_approximant/core/optimizer/optimizer.py</code> <pre><code>def __init__(self, method: str, method_kwargs: dict | None = None):\n\"\"\"\n    Initialize a black box optimizer.\n\n    Parameters\n    ----------\n    method : str\n        The desired optimization method.\n    method_kwargs : dict\n        A dictionary with keyword arguments for the optimizer.\n    \"\"\"\n    if method in BlackBoxOptimizer.blackbox_methods:\n        self.method = method\n        self.method_kwargs = {} if method_kwargs is None else method_kwargs\n    else:\n        raise ValueError(f\"Optimization {method} is not supported.\")\n</code></pre>"},{"location":"reference/core/optimizer/optimizer/#qubit_approximant.core.optimizer.optimizer.BlackBoxOptimizer.__call__","title":"<code>__call__(cost, grad_cost, init_params)</code>","text":"<p>Calculate the optimized parameters using <code>scipy.optimize.minimize()</code>.</p> <p>Parameters:</p> Name Type Description Default <code>cost</code> <code>Callable</code> <p>Cost function to be minimized.</p> required <code>grad_cost</code> <code>Callable</code> <p>Gradient of the cost function.</p> required <code>init_params</code> <code>NDArray</code> <p>Initial parameter guess for the cost function; used to initialize the optimizer.</p> required <p>Returns:</p> Type Description <code>NDArray</code> <p>Optimum parameters</p> Source code in <code>qubit_approximant/core/optimizer/optimizer.py</code> <pre><code>def __call__(self, cost: Callable, grad_cost: Callable, init_params: NDArray) -&gt; NDArray:\n\"\"\"\n    Calculate the optimized parameters using `scipy.optimize.minimize()`.\n\n    Parameters\n    ----------\n    cost: Callable\n        Cost function to be minimized.\n    grad_cost: Callable\n        Gradient of the cost function.\n    init_params : NDArray\n        Initial parameter guess for the cost function; used to initialize the optimizer.\n\n    Returns\n    -------\n    NDArray\n        Optimum parameters\n    \"\"\"\n    result = minimize(\n        cost, init_params, method=self.method, jac=grad_cost, options=self.method_kwargs\n    )\n    params = result.x\n    return params\n</code></pre>"},{"location":"reference/core/optimizer/optimizer/#qubit_approximant.core.optimizer.optimizer.GDOptimizer","title":"<code>GDOptimizer(iters, step_size)</code>","text":"<p>         Bases: <code>Optimizer</code></p> <p>Gradient descent optimizer.</p> <p>iters : int     The number of gradient descent iterations to perform. step_size : float     The size of the step of each gradient descent iteration.</p> Source code in <code>qubit_approximant/core/optimizer/optimizer.py</code> <pre><code>def __init__(self, iters: int, step_size: float):\n\"\"\"\n    Parameters\n    ----------\n    iters : int\n        The number of gradient descent iterations to perform.\n    step_size : float\n        The size of the step of each gradient descent iteration.\n    \"\"\"\n    self.step_size = step_size\n    self._iters = iters\n</code></pre>"},{"location":"reference/core/optimizer/optimizer/#qubit_approximant.core.optimizer.optimizer.GDOptimizer.iters","title":"<code>iters</code>  <code>property</code> <code>writable</code>","text":"<p>Number of iterations of gradient descent.</p>"},{"location":"reference/core/optimizer/optimizer/#qubit_approximant.core.optimizer.optimizer.GDOptimizer.__call__","title":"<code>__call__(cost, grad_cost, params)</code>","text":"<p>Calculate the optimized parameters using a number of gradient descent iterations.</p> <p>Parameters:</p> Name Type Description Default <code>cost</code> <code>Callable</code> <p>Cost function to be minimized.</p> required <code>grad_cost</code> <code>Callable</code> <p>Gradient of the cost function.</p> required <code>params</code> <code>NDArray</code> <p>Initial parameter guess for the cost function; used to initialize the optimizer.</p> required <p>Returns:</p> Type Description <code>NDArray</code> <p>Optimum parameters</p> Source code in <code>qubit_approximant/core/optimizer/optimizer.py</code> <pre><code>def __call__(self, cost: Callable, grad_cost: Callable, params: NDArray) -&gt; NDArray:\n\"\"\"\n    Calculate the optimized parameters using a number of gradient descent iterations.\n\n    Parameters\n    ----------\n    cost : Callable\n        Cost function to be minimized.\n    grad_cost : Callable\n        Gradient of the cost function.\n    params : NDArray\n        Initial parameter guess for the cost function; used to initialize the optimizer.\n\n    Returns\n    -------\n    NDArray\n        Optimum parameters\n    \"\"\"\n    min_cost = 100000\n    min_params = zeros_like(params)\n\n    for i in range(self.iters):\n        self.iter_index = i\n        params = self.step(grad_cost, params)\n\n        if (c := cost(params)) &lt; min_cost:\n            self.min_cost = c\n            min_params = params\n\n    return min_params\n</code></pre>"},{"location":"reference/core/optimizer/optimizer/#qubit_approximant.core.optimizer.optimizer.GDOptimizer.step","title":"<code>step(grad_cost, params)</code>","text":"<p>Update the parameters with a step of Gradient Descent.</p> Source code in <code>qubit_approximant/core/optimizer/optimizer.py</code> <pre><code>def step(self, grad_cost: Callable, params: NDArray) -&gt; NDArray:\n\"\"\"Update the parameters with a step of Gradient Descent.\"\"\"\n    params = params - grad_cost(params) * self.step_size\n    return params\n</code></pre>"},{"location":"reference/core/optimizer/optimizer/#qubit_approximant.core.optimizer.optimizer.Optimizer","title":"<code>Optimizer</code>","text":"<p>         Bases: <code>ABC</code></p> <p>Optimize our quantum circuit.</p>"},{"location":"reference/core/optimizer/optimizer/#qubit_approximant.core.optimizer.optimizer.Optimizer.__call__","title":"<code>__call__(cost, grad_cost, init_params)</code>  <code>abstractmethod</code>","text":"<p>Calculate the optimized parameters.</p> <p>Parameters:</p> Name Type Description Default <code>cost</code> <code>Callable</code> <p>Cost function to be minimized.</p> required <code>grad_cost</code> <code>Callable</code> <p>Gradient of the cost function.</p> required <code>init_params</code> <code>NDArray</code> <p>Initial parameter guess for the cost function; used to initialize the optimizer.</p> required <p>Returns:</p> Type Description <code>NDArray</code> <p>Optimum parameters</p> Source code in <code>qubit_approximant/core/optimizer/optimizer.py</code> <pre><code>@abstractmethod\ndef __call__(self, cost: Callable, grad_cost: Callable, init_params: NDArray) -&gt; NDArray:\n\"\"\"\n    Calculate the optimized parameters.\n\n    Parameters\n    ----------\n    cost: Callable\n        Cost function to be minimized.\n    grad_cost: Callable\n        Gradient of the cost function.\n    init_params : NDArray\n        Initial parameter guess for the cost function; used to initialize the optimizer.\n\n    Returns\n    -------\n    NDArray\n        Optimum parameters\n    \"\"\"\n    ...\n</code></pre>"}]}